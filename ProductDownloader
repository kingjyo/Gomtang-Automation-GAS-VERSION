/**
 * 품목별 시트 엑셀 다운로드 처리기
 * ProductDownloader.gs
 */

const ProductDownloader = {
  /**
   * 사용 가능한 제품 목록
   */
  PRODUCTS: [
    '사골고기곰탕',
    '사골곰탕', 
    '육포'
  ],

  /**
   * 품목별 시트들을 하나의 엑셀 파일로 다운로드
   */
  downloadProductSheets: function(targetDate) {
    console.log('=== 품목별 시트 다운로드 시작 ===');
    console.log('Target date:', targetDate);
    
    try {
      // 설정 초기화
      initializeConfig();
      
      // 날짜 처리
      let dateString;
      if (targetDate) {
        if (targetDate.length === 4) {
          // MMDD 형식을 YYYYMMDD로 변환
          const currentYear = new Date().getFullYear();
          const month = targetDate.substring(0, 2);
          const day = targetDate.substring(2, 4);
          dateString = currentYear + month + day;
        } else {
          // YYYYMMDD 형식
          dateString = targetDate.replace(/\//g, '').replace(/-/g, '');
        }
      } else {
        dateString = getTodayDate();
      }
      
      console.log('Using date string:', dateString);
      
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const availableSheets = [];
      const foundSheets = [];
      
      // 각 제품별로 시트 확인
      for (const product of this.PRODUCTS) {
        const sheetName = `${dateString}_${product}`;
        console.log(`Looking for sheet: ${sheetName}`);
        
        const sheet = spreadsheet.getSheetByName(sheetName);
        if (sheet) {
          console.log(`Found sheet: ${sheetName}`);
          availableSheets.push(sheetName);
          foundSheets.push({
            originalSheet: sheet,
            productName: product,
            sheetName: sheetName
          });
        } else {
          console.log(`Sheet not found: ${sheetName}`);
        }
      }
      
      if (foundSheets.length === 0) {
        return {
          success: false,
          error: `${dateString} 날짜의 품목별 시트를 찾을 수 없습니다.\n다음 형식의 시트가 필요합니다:\n- ${dateString}_사골고기곰탕\n- ${dateString}_사골곰탕\n- ${dateString}_육포`
        };
      }
      
      // 하나의 엑셀 파일에 모든 시트 포함
      const downloadInfo = this.createCombinedExcelFile(foundSheets, dateString);
      
      console.log('=== 품목별 시트 다운로드 완료 ===');
      return {
        success: true,
        message: `${foundSheets.length}개 품목이 포함된 엑셀 파일을 생성했습니다.`,
        availableSheets: availableSheets,
        downloadInfo: downloadInfo,
        dateString: dateString
      };
      
    } catch (error) {
      console.error('품목별 시트 다운로드 실패:', error);
      return {
        success: false,
        error: '다운로드 실패: ' + error.toString()
      };
    }
  },

  /**
   * 여러 시트를 하나의 엑셀 파일로 통합
   */
  createCombinedExcelFile: function(foundSheets, dateString) {
    console.log(`=== Creating combined Excel file for ${foundSheets.length} sheets ===`);
    
    try {
      // 새로운 스프레드시트 생성
      const tempSpreadsheet = SpreadsheetApp.create(`temp_품목별_${dateString}`);
      console.log(`Created temp spreadsheet: temp_품목별_${dateString}`);
      
      // 기본 시트 삭제 (나중에 새로운 시트들로 대체)
      const defaultSheet = tempSpreadsheet.getActiveSheet();
      
      // 각 제품별 시트 추가
      for (const sheetInfo of foundSheets) {
        console.log(`Adding sheet for: ${sheetInfo.productName}`);
        
        // 새 시트 생성 (제품명만, YYYYMMDD_ 접두사 없이)
        const newSheet = tempSpreadsheet.insertSheet(sheetInfo.productName);
        
        // 원본 시트의 모든 데이터 복사
        const sourceData = sheetInfo.originalSheet.getDataRange().getValues();
        console.log(`Copying ${sourceData.length} rows for ${sheetInfo.productName}`);
        
        if (sourceData.length > 0) {
          newSheet.getRange(1, 1, sourceData.length, sourceData[0].length).setValues(sourceData);
          
          // 서식도 복사
          this.copySheetFormatting(sheetInfo.originalSheet, newSheet);
        }
      }
      
      // 기본 시트 삭제
      if (tempSpreadsheet.getSheets().length > foundSheets.length) {
        tempSpreadsheet.deleteSheet(defaultSheet);
      }
      
      // Drive API를 사용해 엑셀로 변환
      const tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
      
      // 엑셀 파일명 - 공식 형식: "간편식 수기송장 (MM.DD).xlsx"
      const month = dateString.substring(4, 6);
      const day = dateString.substring(6, 8);
      const excelFileName = `간편식 수기송장 (${month}.${day}).xlsx`;
      
      // 엑셀 형식으로 변환
      const excelBlob = this.convertToExcel(tempSpreadsheet.getId(), excelFileName);
      
      // 임시 스프레드시트 삭제
      DriveApp.getFileById(tempSpreadsheet.getId()).setTrashed(true);
      console.log('Temp spreadsheet deleted');
      
      // 드라이브에 엑셀 파일 저장
      const excelFile = DriveApp.createFile(excelBlob);
      excelFile.setName(excelFileName);
      
      // 날짜 폴더로 이동
      this.moveToDateFolder(excelFile.getId(), dateString, excelFileName);
      
      // 실제 다운로드 URL 생성 (export link 사용)
      const downloadUrl = `https://drive.google.com/uc?export=download&id=${excelFile.getId()}`;
      
      console.log(`Combined Excel file created successfully: ${excelFileName}`);
      console.log(`Download URL: ${downloadUrl}`);
      
      return {
        fileName: excelFileName,
        fileId: excelFile.getId(),
        downloadUrl: downloadUrl,
        sheetsIncluded: foundSheets.map(s => s.productName)
      };
      
    } catch (error) {
      console.error(`Error creating combined Excel file:`, error);
      throw error;
    }
  },

  /**
   * 개별 시트에서 엑셀 파일 생성 (더 이상 사용하지 않음)
   */
  createExcelFile: function(sheet, productName, dateString) {
    console.log(`=== Creating Excel file for: ${productName} ===`);
    
    try {
      // 새로운 스프레드시트 생성
      const tempSpreadsheet = SpreadsheetApp.create(`temp_${productName}_${dateString}`);
      console.log(`Created temp spreadsheet: temp_${productName}_${dateString}`);
      
      // 기본 시트 이름을 제품명으로 변경
      const tempSheet = tempSpreadsheet.getActiveSheet();
      tempSheet.setName(productName); // YYYYMMDD_ 접두사 없이 제품명만
      console.log(`Renamed sheet to: ${productName}`);
      
      // 원본 시트의 모든 데이터 복사
      const sourceData = sheet.getDataRange().getValues();
      console.log(`Source data rows: ${sourceData.length}`);
      
      if (sourceData.length > 0) {
        tempSheet.getRange(1, 1, sourceData.length, sourceData[0].length).setValues(sourceData);
        console.log('Data copied successfully');
        
        // 원본 시트의 서식도 복사 (헤더 스타일 등)
        this.copySheetFormatting(sheet, tempSheet);
      }
      
      // Drive API를 사용해 엑셀로 변환
      const tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
      
      // 엑셀 파일명 (날짜_제품명.xlsx)
      const excelFileName = `${dateString}_${productName}.xlsx`;
      
      // 엑셀 형식으로 변환
      const blob = tempFile.getBlob();
      const excelBlob = this.convertToExcel(blob, excelFileName);
      
      // 임시 스프레드시트 삭제
      DriveApp.getFileById(tempSpreadsheet.getId()).setTrashed(true);
      console.log('Temp spreadsheet deleted');
      
      // 드라이브에 엑셀 파일 저장
      const excelFile = DriveApp.createFile(excelBlob);
      
      // 날짜 폴더로 이동
      this.moveToDateFolder(excelFile.getId(), dateString, excelFileName);
      
      // 다운로드 URL 생성
      const downloadUrl = `https://drive.google.com/file/d/${excelFile.getId()}/view`;
      
      console.log(`Excel file created successfully: ${excelFileName}`);
      console.log(`Download URL: ${downloadUrl}`);
      
      return downloadUrl;
      
    } catch (error) {
      console.error(`Error creating Excel file for ${productName}:`, error);
      throw error;
    }
  },

  /**
   * 시트 서식 복사
   */
  copySheetFormatting: function(sourceSheet, targetSheet) {
    try {
      const lastRow = sourceSheet.getLastRow();
      const lastCol = sourceSheet.getLastColumn();
      
      if (lastRow > 0 && lastCol > 0) {
        // 헤더 행 (첫 번째 행) 서식 복사
        if (lastRow >= 1) {
          const headerRange = sourceSheet.getRange(1, 1, 1, lastCol);
          const targetHeaderRange = targetSheet.getRange(1, 1, 1, lastCol);
          
          // 배경색 복사
          const backgrounds = headerRange.getBackgrounds();
          targetHeaderRange.setBackgrounds(backgrounds);
          
          // 폰트 스타일 복사
          const fontWeights = headerRange.getFontWeights();
          targetHeaderRange.setFontWeights(fontWeights);
          
          // 텍스트 색상 복사
          const fontColors = headerRange.getFontColors();
          targetHeaderRange.setFontColors(fontColors);
          
          console.log('Header formatting copied');
        }
        
        // 열 너비 복사
        for (let col = 1; col <= lastCol; col++) {
          const width = sourceSheet.getColumnWidth(col);
          targetSheet.setColumnWidth(col, width);
        }
        
        console.log('Column widths copied');
      }
    } catch (error) {
      console.log('Warning: Could not copy all formatting:', error.toString());
    }
  },

  /**
   * Google Sheets를 Excel 형식으로 변환
   */
  convertToExcel: function(spreadsheetId, fileName) {
    try {
      console.log(`Converting spreadsheet ${spreadsheetId} to Excel...`);
      
      // Drive API v3를 사용하여 Excel 형식으로 export
      const exportUrl = `https://www.googleapis.com/drive/v3/files/${spreadsheetId}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
      
      const response = UrlFetchApp.fetch(exportUrl, {
        headers: {
          'Authorization': `Bearer ${ScriptApp.getOAuthToken()}`
        }
      });
      
      if (response.getResponseCode() !== 200) {
        throw new Error(`Failed to export Excel: ${response.getResponseCode()}`);
      }
      
      console.log('Excel conversion successful');
      
      // Excel blob 반환
      return Utilities.newBlob(
        response.getContent(),
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        fileName
      );
      
    } catch (error) {
      console.error('Excel conversion failed:', error);
      throw error;
    }
  },

  /**
   * 파일을 날짜 폴더로 이동
   */
  moveToDateFolder: function(fileId, dateString, fileName) {
    try {
      const file = DriveApp.getFileById(fileId);
      const parentFolderId = CONFIG.FOLDER_ID;
      
      if (!parentFolderId || parentFolderId === 'YOUR_FOLDER_ID') {
        console.log('폴더 ID가 설정되지 않아 루트 폴더에 저장됩니다.');
        return;
      }
      
      const parentFolder = DriveApp.getFolderById(parentFolderId);
      
      // 날짜 폴더 생성 또는 가져오기
      const folders = parentFolder.getFoldersByName(dateString);
      let dateFolder;
      
      if (folders.hasNext()) {
        dateFolder = folders.next();
      } else {
        dateFolder = parentFolder.createFolder(dateString);
      }
      
      // 다운로드 하위 폴더 생성 또는 가져오기
      const downloadFolders = dateFolder.getFoldersByName('다운로드');
      let downloadFolder;
      
      if (downloadFolders.hasNext()) {
        downloadFolder = downloadFolders.next();
      } else {
        downloadFolder = dateFolder.createFolder('다운로드');
      }
      
      // 같은 이름의 기존 파일이 있으면 삭제
      const existingFiles = downloadFolder.getFilesByName(fileName);
      while (existingFiles.hasNext()) {
        const existingFile = existingFiles.next();
        existingFile.setTrashed(true);
      }
      
      // 파일 이동
      downloadFolder.addFile(file);
      
      // 원래 위치에서 제거
      const parents = file.getParents();
      while (parents.hasNext()) {
        const parent = parents.next();
        if (parent.getId() !== downloadFolder.getId()) {
          parent.removeFile(file);
        }
      }
      
      console.log(`파일이 ${dateString}/다운로드 폴더로 이동되었습니다.`);
      
    } catch (error) {
      console.error('파일 이동 실패:', error);
    }
  },

  /**
   * 이메일 설정 시트 초기화
   */
  initializeEmailSettings: function() {
    console.log('=== 이메일 설정 시트 초기화 ===');
    
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const settingsSheetName = '이메일_설정';
      
      // 기존 설정 시트 확인
      let settingsSheet = spreadsheet.getSheetByName(settingsSheetName);
      
      if (!settingsSheet) {
        // 설정 시트 생성
        settingsSheet = spreadsheet.insertSheet(settingsSheetName);
        
        // 헤더 설정
        settingsSheet.getRange(1, 1, 1, 5).setValues([
          ['순서', '이름', '이메일 주소', '비고', '전송여부']
        ]);
        
        // 샘플 데이터 추가 (직급 순서대로)
        settingsSheet.getRange(2, 1, 3, 5).setValues([
          [1, '김영준', 'youngjun.kim@company.com', '담당자 (팀장)', true],
          [2, '홍길동', 'gildong.hong@partner.com', '파트너 (대리)', true],
          [3, '이철수', 'chulsoo.lee@client.com', '고객 (사원)', false]
        ]);
        
        // 헤더 스타일 적용
        const headerRange = settingsSheet.getRange(1, 1, 1, 5);
        headerRange.setBackground('#4285f4');
        headerRange.setFontColor('#ffffff');
        headerRange.setFontWeight('bold');
        
        // 열 너비 조정
        settingsSheet.setColumnWidth(1, 60);  // 순서
        settingsSheet.setColumnWidth(2, 120); // 이름
        settingsSheet.setColumnWidth(3, 250); // 이메일 주소
        settingsSheet.setColumnWidth(4, 150); // 비고
        settingsSheet.setColumnWidth(5, 80);  // 전송여부
        
        // 전송여부 컬럼을 체크박스로 설정
        const checkboxRange = settingsSheet.getRange(2, 5, 100, 1); // E2:E101 범위
        checkboxRange.insertCheckboxes();
        
        console.log('이메일 설정 시트가 생성되었습니다.');
      }
      
      return {
        success: true,
        message: '이메일 설정 시트가 준비되었습니다.'
      };
      
    } catch (error) {
      console.error('이메일 설정 시트 초기화 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  },

  /**
   * 이메일 주소 목록 가져오기
   */
  getEmailRecipients: function() {
    console.log('=== 이메일 주소 목록 가져오기 ===');
    
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const settingsSheet = spreadsheet.getSheetByName('이메일_설정');
      
      if (!settingsSheet) {
        // 설정 시트가 없으면 초기화
        const initResult = this.initializeEmailSettings();
        if (!initResult.success) {
          return initResult;
        }
        return this.getEmailRecipients(); // 재귀 호출
      }
      
      const data = settingsSheet.getDataRange().getValues();
      const recipients = [];
      
      // 헤더 행 제외하고 처리
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const order = parseInt(row[0] || 999); // A열: 우선순위 (기본값 999)
        const sendEnabled = String(row[1] || '').toUpperCase() === 'TRUE'; // B열: 전송여부 (TRUE/FALSE)
        const name = String(row[2] || '').trim(); // C열: 이름
        const email = String(row[3] || '').trim(); // D열: 이메일 주소
        const memo = String(row[4] || '').trim(); // E열: 메모
        
        console.log(`Processing row ${i}: order=${order}, sendEnabled=${sendEnabled}, name="${name}", email="${email}"`);
        
        if (name && email && email.includes('@') && sendEnabled) {
          recipients.push({
            order: order,
            name: name,
            email: email,
            memo: memo,
            sendEnabled: sendEnabled
          });
        }
      }
      
      // 순서대로 정렬 (직급이 높은 순서대로)
      recipients.sort((a, b) => a.order - b.order);
      
      console.log(`Found ${recipients.length} email recipients (sorted by order)`);
      console.log('Recipients order:', recipients.map(r => `${r.order}: ${r.name}`));
      
      return {
        success: true,
        recipients: recipients
      };
      
    } catch (error) {
      console.error('이메일 주소 목록 가져오기 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  },

  /**
   * 이메일로 간편식 수기송장 전송
   */
  sendShipmentEmail: function(targetDate, recipients, excelFileId, fileName) {
    console.log('=== 이메일 전송 시작 ===');
    console.log('Parameters:', { targetDate, recipients, fileName });
    
    try {
      // 설정 초기화
      initializeConfig();
      
      // 날짜 처리
      let dateString;
      if (targetDate) {
        if (targetDate.length === 4) {
          // MMDD 형식을 YYYYMMDD로 변환
          const currentYear = new Date().getFullYear();
          const month = targetDate.substring(0, 2);
          const day = targetDate.substring(2, 4);
          dateString = currentYear + month + day;
        } else {
          // YYYYMMDD 형식
          dateString = targetDate.replace(/\//g, '').replace(/-/g, '');
        }
      } else {
        dateString = getTodayDate();
      }
      
      // 출고 수량 데이터 수집
      const shipmentData = this.collectShipmentData(dateString);
      if (!shipmentData.success) {
        return shipmentData;
      }
      
      // 이메일 내용 생성
      const emailContent = this.generateEmailContent(shipmentData.data, dateString);
      
      // 첨부파일 준비
      const attachment = DriveApp.getFileById(excelFileId);
      
      // 이메일 전송
      const subject = `${dateString.substring(4,6)}.${dateString.substring(6,8)} 간편식 출고요청`;
      
      GmailApp.sendEmail(
        recipients, // 받는 사람 (콤마로 구분)
        subject,
        emailContent, // 텍스트 본문
        {
          attachments: [attachment.getBlob()],
          name: '한국공항 김영준'
        }
      );
      
      console.log('=== 이메일 전송 완료 ===');
      return {
        success: true,
        message: `이메일이 성공적으로 전송되었습니다.\n받는 사람: ${recipients}`,
        recipientCount: recipients.split(',').length,
        shipmentSummary: shipmentData.data
      };
      
    } catch (error) {
      console.error('이메일 전송 실패:', error);
      return {
        success: false,
        error: '이메일 전송 실패: ' + error.toString()
      };
    }
  },

  /**
   * 출고 수량 데이터 수집 (싸이버스카이 + 쿠팡)
   */
  collectShipmentData: function(dateString) {
    console.log(`=== 출고 데이터 수집 (싸이버스카이 + 쿠팡): ${dateString} ===`);
    
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const shipmentData = {
        '사골고기곰탕5개입': { cybersky: 0, coupang: 0, total: 0 },
        '사골곰탕5개입': { cybersky: 0, coupang: 0, total: 0 },
        '사골곰탕20개입': { cybersky: 0, coupang: 0, total: 0 },
        '사골곰탕10개입': { cybersky: 0, coupang: 0, total: 0 },
        '육포5개입': { cybersky: 0, coupang: 0, total: 0 }
      };
      
      // 1. 싸이버스카이 시트에서 데이터 읽기
      const cyberskySheetName = `${dateString}_간편식_싸이버스카이`;
      const cyberskySheet = spreadsheet.getSheetByName(cyberskySheetName);
      
      console.log(`🔍 싸이버스카이 시트 찾기: ${cyberskySheetName}`);
      
      if (cyberskySheet) {
        console.log(`✅ 싸이버스카이 시트 발견: ${cyberskySheet.getName()}`);
        this.processCyberskySheetForProductDownloader(cyberskySheet, shipmentData);
      } else {
        console.log(`⚠️ 싸이버스카이 시트 없음: ${cyberskySheetName}`);
      }
      
      // 2. 검산결과 시트에서 쿠팡 데이터 읽기
      const verificationSheetName = `${dateString}_검산결과`;
      const verificationSheet = spreadsheet.getSheetByName(verificationSheetName);
      
      console.log(`🔍 검산결과 시트 찾기: ${verificationSheetName}`);
      
      if (verificationSheet) {
        console.log(`✅ 검산결과 시트 발견: ${verificationSheet.getName()}`);
        this.processCoupangDataForProductDownloader(verificationSheet, shipmentData);
      } else {
        console.log(`⚠️ 검산결과 시트 없음: ${verificationSheetName}`);
      }
      
      // 최종 결과 로깅
      console.log('📊 최종 출고 데이터:');
      let totalQuantity = 0;
      for (const [product, data] of Object.entries(shipmentData)) {
        if (data.total > 0) {
          console.log(`  ${product}: 총 ${data.total}개 (싸이버스카이: ${data.cybersky}, 쿠팡: ${data.coupang})`);
          totalQuantity += data.total;
        }
      }
      console.log(`✅ 총 출고량: ${totalQuantity}개`);
      
      return {
        success: true,
        data: shipmentData
      };
      
    } catch (error) {
      console.error('출고 데이터 수집 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  },

  /**
   * 싸이버스카이 시트 처리 (ProductDownloader용)
   */
  processCyberskySheetForProductDownloader: function(cyberskySheet, shipmentData) {
    console.log('📋 싸이버스카이 시트 데이터 처리 시작 (ProductDownloader)');
    
    const data = cyberskySheet.getDataRange().getValues();
    console.log(`  └─ 시트 크기: ${data.length} 행 x ${data[0] ? data[0].length : 0} 열`);
    
    if (data.length <= 1) {
      console.log(`  └─ ⚠️ 데이터 없음`);
      return;
    }
    
    // 고정 열 인덱스 사용
    const productColIndex = 15; // P열: PROD_NAME (0-based index)
    const quantityColIndex = 19; // T열: ORDERCNT (0-based index)
    
    const headers = data[0];
    console.log(`  └─ 📍 고정 열 사용 - P열(${productColIndex}): ${headers[productColIndex]}, T열(${quantityColIndex}): ${headers[quantityColIndex]}`);
    
    let processedRows = 0;
    
    // 데이터 행 처리
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const productName = String(row[productColIndex] || '');
      const quantity = parseInt(row[quantityColIndex] || 0);
      
      if (quantity > 0 && productName) {
        const normalizedProduct = this.normalizeProductNameForProductDownloader(productName);
        
        if (normalizedProduct && shipmentData[normalizedProduct]) {
          shipmentData[normalizedProduct].cybersky += quantity;
          shipmentData[normalizedProduct].total += quantity;
          processedRows++;
        }
      }
    }
    
    console.log(`✅ 싸이버스카이 처리 완료: ${processedRows}개 행 처리`);
  },

  /**
   * 검산결과 시트에서 쿠팡 데이터 처리 (ProductDownloader용)
   */
  processCoupangDataForProductDownloader: function(verificationSheet, shipmentData) {
    console.log('📋 검산결과 시트에서 쿠팡 데이터 처리 시작 (ProductDownloader)');
    
    const data = verificationSheet.getDataRange().getValues();
    console.log(`  └─ 검산결과 시트 크기: ${data.length} 행 x ${data[0] ? data[0].length : 0} 열`);
    
    if (data.length <= 1) {
      console.log(`  └─ ⚠️ 검산결과 시트에 데이터 없음`);
      return 0;
    }
    
    // H열(7)에 쿠팡 수량이 있는 행들에서 쿠팡 데이터 읽기
    let coupangCount = 0;
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const productName = String(row[1] || ''); // B열: 품목명
      const coupangQuantity = parseInt(row[7] || 0); // H열: 쿠팡 수량
      
      if (coupangQuantity > 0 && productName) {
        console.log(`    🛒 쿠팡 데이터 발견: "${productName}" / 쿠팡수량=${coupangQuantity}`);
        
        const normalizedProduct = this.normalizeProductNameForProductDownloader(productName);
        
        if (normalizedProduct && shipmentData[normalizedProduct]) {
          shipmentData[normalizedProduct].coupang += coupangQuantity;
          shipmentData[normalizedProduct].total += coupangQuantity;
          coupangCount++;
          
          console.log(`    ➕ 쿠팡 추가: ${normalizedProduct} +${coupangQuantity} (새 총계: ${shipmentData[normalizedProduct].total})`);
        }
      }
    }
    
    console.log(`✅ 쿠팡 데이터 처리 완료: ${coupangCount}개 항목 처리`);
    return coupangCount;
  },

  /**
   * 제품명 정규화 (ProductDownloader용)
   */
  normalizeProductNameForProductDownloader: function(productName) {
    if (productName.includes('사골고기곰탕')) {
      return '사골고기곰탕5개입';
    }
    else if (productName.includes('사골곰탕') && (productName.includes('20팩') || productName.includes('20개입'))) {
      return '사골곰탕20개입';
    }
    else if (productName.includes('사골곰탕') && (productName.includes('10팩') || productName.includes('10개입'))) {
      return '사골곰탕10개입';
    }
    else if (productName.includes('사골곰탕') && !productName.includes('사골고기곰탕') && 
            (productName.includes('5팩') || productName.includes('5개입') || productName.includes('1박스'))) {
      return '사골곰탕5개입';
    }
    else if (productName.includes('육포')) {
      return '육포5개입';
    }
    
    return null;
  },

  /**
   * 이메일 내용 생성
   */
  generateEmailContent: function(shipmentData, dateString) {
    console.log('=== 이메일 내용 생성 ===');
    
    // 날짜 포맷팅 (YY.MM)
    const year = dateString.substring(2, 4);
    const month = dateString.substring(4, 6);
    const day = dateString.substring(6, 8);
    
    // 이메일 본문 시작 (HTML 없이 순수 텍스트)
    let emailBody = `안녕하세요 한국공항 김영준 사원입니다
금일 간편식 출고요청 드립니다

금일 출고목록

`;

    // 각 제품별 출고량 추가 (수량이 0인 것은 제외)
    const productLabels = {
      '사골고기곰탕5개입': '제동 사골고기곰탕 5개입',
      '사골곰탕5개입': '제동 사골곰탕 5개입',
      '사골곰탕20개입': '제동 사골곰탕 20개입',
      '사골곰탕10개입': '제동 사골곰탕 10개입',
      '육포5개입': '제동한우 육포 5개입'
    };

    for (const [product, data] of Object.entries(shipmentData)) {
      if (data.total > 0) {
        const label = productLabels[product] || product;
        emailBody += `${label} X ${data.total}박스\n`;
      }
    }

    emailBody += `
감사합니다

김영준 드림`;

    return emailBody;
  },

  /**
   * 사용 가능한 품목별 시트 목록 조회
   */
  getAvailableProductSheets: function(targetDate) {
    console.log('=== 사용 가능한 품목별 시트 조회 ===');
    
    try {
      // 날짜 처리
      let dateString;
      if (targetDate) {
        if (targetDate.length === 4) {
          // MMDD 형식을 YYYYMMDD로 변환
          const currentYear = new Date().getFullYear();
          const month = targetDate.substring(0, 2);
          const day = targetDate.substring(2, 4);
          dateString = currentYear + month + day;
        } else {
          // YYYYMMDD 형식
          dateString = targetDate.replace(/\//g, '').replace(/-/g, '');
        }
      } else {
        dateString = getTodayDate();
      }
      
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const availableSheets = [];
      
      // 각 제품별로 시트 확인
      for (const product of this.PRODUCTS) {
        const sheetName = `${dateString}_${product}`;
        const sheet = spreadsheet.getSheetByName(sheetName);
        
        if (sheet) {
          const lastRow = sheet.getLastRow();
          availableSheets.push({
            product: product,
            sheetName: sheetName,
            rowCount: lastRow,
            hasData: lastRow > 1 // 헤더 행 제외하고 데이터가 있는지
          });
        }
      }
      
      return {
        success: true,
        dateString: dateString,
        availableSheets: availableSheets,
        totalSheets: availableSheets.length
      };
      
    } catch (error) {
      console.error('시트 목록 조회 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  }
};

/**
 * HTML에서 호출할 전역 함수들
 */

// 품목별 시트 다운로드
function downloadProductSheets(targetDate) {
  console.log('=== Global Function Start: downloadProductSheets ===');
  console.log('Parameters:', { targetDate });
  
  try {
    const result = ProductDownloader.downloadProductSheets(targetDate);
    console.log('Download result:', result);
    console.log('=== Global Function End: downloadProductSheets SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in global downloadProductSheets:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: downloadProductSheets FAILED ===');
    return { success: false, error: error.toString() };
  }
}

// 사용 가능한 품목별 시트 조회
function getAvailableProductSheets(targetDate) {
  console.log('=== Global Function Start: getAvailableProductSheets ===');
  console.log('Parameters:', { targetDate });
  
  try {
    const result = ProductDownloader.getAvailableProductSheets(targetDate);
    console.log('Available sheets result:', result);
    console.log('=== Global Function End: getAvailableProductSheets SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in global getAvailableProductSheets:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: getAvailableProductSheets FAILED ===');
    return { success: false, error: error.toString() };
  }
}

// 파일 다운로드 트리거 (HtmlService에서 호출)
function triggerDownload(fileId, fileName) {
  console.log('=== Global Function Start: triggerDownload ===');
  console.log('Parameters:', { fileId, fileName });
  
  try {
    // 다운로드 URL 생성
    const downloadUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
    
    console.log('=== Global Function End: triggerDownload SUCCESS ===');
    return { 
      success: true, 
      downloadUrl: downloadUrl,
      fileName: fileName,
      message: '다운로드 링크가 준비되었습니다.'
    };
    
  } catch (error) {
    console.error('ERROR in global triggerDownload:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: triggerDownload FAILED ===');
    return { success: false, error: error.toString() };
  }
}

// 이메일 설정 시트 초기화
function initializeEmailSettings() {
  console.log('=== Global Function Start: initializeEmailSettings ===');
  
  try {
    const result = ProductDownloader.initializeEmailSettings();
    console.log('Initialize email settings result:', result);
    console.log('=== Global Function End: initializeEmailSettings SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in global initializeEmailSettings:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: initializeEmailSettings FAILED ===');
    return { success: false, error: error.toString() };
  }
}

// 이메일 주소 목록 가져오기
function getEmailRecipients() {
  console.log('=== Global Function Start: getEmailRecipients ===');
  
  try {
    const result = ProductDownloader.getEmailRecipients();
    console.log('Get email recipients result:', result);
    console.log('=== Global Function End: getEmailRecipients SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in global getEmailRecipients:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: getEmailRecipients FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
   * 자동 이메일 전송 (트리거용) - 품목별 시트 생성하고 이메일로 전송
   */
  sendEmailWithProductSheets: function(targetDate) {
    console.log('=== 자동 이메일 전송 시작 ===');
    
    try {
      // 날짜 처리
      let dateString;
      if (targetDate) {
        if (targetDate.length === 4) {
          // MMDD 형식을 YYYYMMDD로 변환
          const currentYear = new Date().getFullYear();
          const month = targetDate.substring(0, 2);
          const day = targetDate.substring(2, 4);
          dateString = currentYear + month + day;
        } else {
          // YYYYMMDD 형식
          dateString = targetDate.replace(/\//g, '').replace(/-/g, '');
        }
      } else {
        dateString = getTodayDate();
      }
      
      console.log('자동 이메일 전송 날짜:', dateString);
      
      // 1. 품목별 시트 생성 및 다운로드
      const downloadResult = this.downloadProductSheets(targetDate);
      
      if (!downloadResult.success) {
        return {
          success: false,
          error: '품목별 시트 생성 실패: ' + downloadResult.error,
          step: 'downloadProductSheets'
        };
      }
      
      // 2. 이메일 수신자 목록 가져오기
      const recipientsResult = this.getEmailRecipients();
      if (!recipientsResult.success) {
        return {
          success: false,
          error: '이메일 수신자 목록 조회 실패: ' + recipientsResult.error,
          step: 'getEmailRecipients'
        };
      }
      
      if (recipientsResult.recipients.length === 0) {
        return {
          success: false,
          error: '전송 대상자가 없습니다. 이메일_설정 시트에서 전송여부를 체크해주세요.',
          step: 'noRecipients'
        };
      }
      
      // 3. 출고 데이터 수집
      const shipmentData = this.collectShipmentData(dateString);
      if (!shipmentData.success) {
        return {
          success: false,
          error: '출고 데이터 수집 실패: ' + shipmentData.error,
          step: 'collectShipmentData'
        };
      }
      
      // 4. 이메일 내용 생성
      const emailContent = this.generateEmailContent(shipmentData.data, dateString);
      
      // 5. 첨부 파일 준비 (생성된 엑셀 파일)
      const excelFileId = downloadResult.downloadInfo.fileId;
      const attachment = DriveApp.getFileById(excelFileId);
      
      // 6. 이메일 전송
      const subject = `${dateString.substring(4,6)}.${dateString.substring(6,8)} 간편식 출고요청 (자동전송)`;
      const recipients = recipientsResult.recipients.map(r => r.email).join(',');
      
      GmailApp.sendEmail(
        recipients,
        subject,
        emailContent,
        {
          attachments: [attachment],
          name: '한국공항 김영준 (자동시스템)'
        }
      );
      
      console.log('✅ 자동 이메일 전송 완료');
      
      return {
        success: true,
        message: `자동 이메일 전송 완료 (${dateString})`,
        recipientCount: recipientsResult.recipients.length,
        recipients: recipientsResult.recipients,
        fileName: downloadResult.downloadInfo.fileName,
        fileId: excelFileId,
        shipmentSummary: shipmentData.data
      };
      
    } catch (error) {
      console.error('자동 이메일 전송 실패:', error);
      return {
        success: false,
        error: error.toString(),
        step: 'emailSending'
      };
    }
  }
};

// 이메일 전송 (HtmlService에서 호출)
function sendShipmentEmail(targetDate, recipients, excelFileId, fileName) {
  console.log('=== Global Function Start: sendShipmentEmail ===');
  console.log('Parameters:', { targetDate, recipients, fileName });
  
  try {
    const result = ProductDownloader.sendShipmentEmail(targetDate, recipients, excelFileId, fileName);
    console.log('Email send result:', result);
    console.log('=== Global Function End: sendShipmentEmail SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in global sendShipmentEmail:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Global Function End: sendShipmentEmail FAILED ===');
    return { success: false, error: error.toString() };
  }
}