/**
 * Google Drive 탐색기 기반 파일/폴더 선택기
 * 파일명: GooglePicker.gs
 */

function __init_setPickerConfigOnce() {
  const props = PropertiesService.getScriptProperties();
  // 이미 저장해둔 값 사용해도 됩니다.
  props.setProperty('PICKER_API_KEY', 'AIzaSyBkzoaHZmYgrH9yOkr8dI3GXGM0RyxDABc');
  props.setProperty('GCP_PROJECT_NUMBER', '840962145115');
  SpreadsheetApp.getUi().alert('Picker 설정값 저장 완료');
}

function openGooglePicker() {
  const html = HtmlService.createTemplateFromFile('PickerDialog').evaluate()
    .setWidth(1100)
    .setHeight(760)
    .setTitle('구글 드라이브 파일/폴더 선택');
  SpreadsheetApp.getUi().showModalDialog(html, '📁 구글 드라이브 설정');
}

/** HTML include 헬퍼 */
function include(name) {
  return HtmlService.createHtmlOutputFromFile(name).getContent();
}

/**
 * ✅ Drive 스코프 강제 워밍업
 * - getOAuthToken() 호출 전에 반드시 실행
 * - 최소 권한 접근으로 스코프만 획득 (실제 파일 읽지 않음)
 */
function ensureDriveScope() {
  try {
    // root ID만 터치해서 권한 승인 유도
    DriveApp.getRootFolder().getId();
    return { ok: true };
  } catch (e) {
    return { ok: false, error: String(e) };
  }
}

function getOAuthToken() {
  try { return ScriptApp.getOAuthToken(); }
  catch (e) { console.error('OAuth 토큰 오류:', e); return null; }
}

function getPickerApiKey() {
  return PropertiesService.getScriptProperties().getProperty('PICKER_API_KEY') || '';
}

function getPickerAppId() { // 선택(없어도 동작)
  return PropertiesService.getScriptProperties().getProperty('GCP_PROJECT_NUMBER') || '';
}

/** 빠른 표시용(권한 불필요) */
function getCurrentPickerSettingsLite() {
  const p = PropertiesService.getScriptProperties();
  return {
    success: true,
    settings: {
      sourceSpreadsheetId: p.getProperty('SOURCE_SPREADSHEET_ID') || '',
      sourceSpreadsheetName: '',
      folderId: p.getProperty('FOLDER_ID') || '',
      folderName: ''
    }
  };
}

/** 네트워크/세션 확인용 */
function pingServer() {
  return { ok: true, ts: new Date().toISOString() };
}

/** 이름 포함(Drive 권한 필요, 실패해도 무시) */
function getCurrentPickerSettings() {
  const p = PropertiesService.getScriptProperties();
  const ssId = p.getProperty('SOURCE_SPREADSHEET_ID') || '';
  const folderId = p.getProperty('FOLDER_ID') || '';
  return {
    success: true,
    settings: {
      sourceSpreadsheetId: ssId,
      sourceSpreadsheetName: getDisplayName(ssId),
      folderId: folderId,
      folderName: getDisplayName(folderId)
    }
  };
}

function getDisplayName(id) {
  if (!id) return '';
  try {
    try { return SpreadsheetApp.openById(id).getName(); }
    catch (e1) {
      try { return DriveApp.getFolderById(id).getName(); }
      catch (e2) {
        try { return DriveApp.getFileById(id).getName(); }
        catch (e3) { return '(접근 불가)'; }
      }
    }
  } catch (e) { return '(접근 불가)'; }
}

function savePickerSelection(selection) {
  try {
    const p = PropertiesService.getScriptProperties();
    if (selection?.spreadsheetId) p.setProperty('SOURCE_SPREADSHEET_ID', selection.spreadsheetId);
    if (selection?.folderId) p.setProperty('FOLDER_ID', selection.folderId);
    return { success: true, message: '설정이 저장되었습니다.' };
  } catch (err) {
    return { success: false, error: String(err) };
  }
}

/**
 * 루트 폴더 목록 가져오기 (좌측 내비게이션용)
 */
function getDriveRoots() {
  console.log('=== Function Start: getDriveRoots ===');
  
  try {
    const roots = [];
    
    // 내 드라이브
    console.log('Step 1: Adding My Drive');
    roots.push({
      id: 'root',
      name: '내 드라이브',
      type: 'my_drive',
      icon: '📁'
    });
    
    // 공유 드라이브 카테고리 (개별 드라이브가 아닌 카테고리)
    console.log('Step 2: Adding Shared Drives category');
    roots.push({
      id: 'sharedDrives',
      name: '공유 드라이브',
      type: 'shared_drives_category',
      icon: '📁'
    });
    
    // 공유 문서함
    console.log('Step 3: Adding shared with me');
    roots.push({
      id: 'sharedWithMe',
      name: '공유 문서함',
      type: 'shared',
      icon: '👥'
    });
    
    // 최근 항목
    console.log('Step 4: Adding recent items');
    roots.push({
      id: 'recent',
      name: '최근 항목',
      type: 'recent',
      icon: '🕐'
    });
    
    console.log('Final roots array:', roots);
    console.log('=== Function End: getDriveRoots SUCCESS ===');
    return { success: true, roots };
    
  } catch (error) {
    console.error('ERROR in getDriveRoots:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: getDriveRoots FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 공유 드라이브 목록 가져오기 (공유 드라이브 카테고리 클릭 시)
 */
function getSharedDrivesList() {
  console.log('=== Function Start: getSharedDrivesList ===');
  
  try {
    const drives = [];
    
    console.log('Step 1: Fetching shared drives list');
    try {
      // Drive.Drives API 사용
      const sharedDrives = Drive.Drives.list({ pageSize: 100 });
      console.log('Shared drives response:', sharedDrives);
      
      if (sharedDrives.drives && sharedDrives.drives.length > 0) {
        console.log(`Found ${sharedDrives.drives.length} shared drives`);
        sharedDrives.drives.forEach(drive => {
          drives.push({
            id: drive.id,
            name: drive.name,
            type: 'folder',  // 폴더처럼 취급
            mimeType: 'application/vnd.google-apps.folder',
            icon: '📁'
          });
        });
      } else {
        console.log('No shared drives found');
      }
    } catch (e) {
      console.error('Failed to fetch shared drives:', e);
      return { success: false, error: e.toString() };
    }
    
    console.log(`Returning ${drives.length} shared drives`);
    console.log('=== Function End: getSharedDrivesList SUCCESS ===');
    return { success: true, items: drives, folderId: 'sharedDrives' };
    
  } catch (error) {
    console.error('ERROR in getSharedDrivesList:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: getSharedDrivesList FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 파일 확장자에 따른 아이콘 반환
 */
function getFileIcon(file) {
  const mimeType = file.mimeType;
  const fileName = file.name || '';
  const extension = fileName.split('.').pop().toLowerCase();
  
  // MIME 타입 기반 아이콘
  if (mimeType === 'application/vnd.google-apps.folder') {
    return '📁';
  } else if (mimeType === 'application/vnd.google-apps.spreadsheet' || 
             extension === 'xls' || extension === 'xlsx' || extension === 'csv') {
    return '<i class="fa-solid fa-file-excel" style="color: #107C41;"></i>';
  } else if (mimeType === 'application/vnd.google-apps.document' || 
             extension === 'doc' || extension === 'docx') {
    return '<i class="fa-solid fa-file-word" style="color: #2B579A;"></i>';
  } else if (mimeType === 'application/vnd.google-apps.presentation' || 
             extension === 'ppt' || extension === 'pptx') {
    return '<i class="fa-solid fa-file-powerpoint" style="color: #B7472A;"></i>';
  } else if (extension === 'pdf') {
    return '<i class="fa-solid fa-file-pdf" style="color: #FF0000;"></i>';
  } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(extension)) {
    return '<i class="fa-solid fa-file-image" style="color: #4285F4;"></i>';
  } else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv'].includes(extension)) {
    return '<i class="fa-solid fa-file-video" style="color: #EA4335;"></i>';
  } else if (['mp3', 'wav', 'flac', 'aac', 'ogg'].includes(extension)) {
    return '<i class="fa-solid fa-file-audio" style="color: #FBBC04;"></i>';
  } else if (['zip', 'rar', '7z', 'tar', 'gz'].includes(extension)) {
    return '<i class="fa-solid fa-file-zipper" style="color: #34A853;"></i>';
  } else if (['txt', 'md', 'log'].includes(extension)) {
    return '<i class="fa-solid fa-file-lines" style="color: #5F6368;"></i>';
  } else if (['js', 'py', 'java', 'cpp', 'c', 'html', 'css', 'json', 'xml'].includes(extension)) {
    return '<i class="fa-solid fa-file-code" style="color: #673AB7;"></i>';
  } else {
    return '<i class="fa-solid fa-file" style="color: #9AA0A6;"></i>';
  }
}

/**
 * 폴더 내용 가져오기
 */
function getDriveFolderContents(folderId, filterType = 'all', pageToken = null) {
  console.log('=== Function Start: getDriveFolderContents ===');
  console.log('Parameters:', { folderId, filterType, pageToken });
  
  try {
    const items = [];
    let query = '';
    
    console.log('Step 1: Building query for folder:', folderId);
    
    // 기본 쿼리 설정
    if (folderId === 'root') {
      query = "'root' in parents and trashed = false";
    } else if (folderId === 'sharedWithMe') {
      query = "sharedWithMe and trashed = false";
    } else if (folderId === 'sharedDrives') {
      // 공유 드라이브 목록을 별도 함수로 처리
      console.log('Special case: shared drives category');
      console.log('=== Function End: getDriveFolderContents SUCCESS (delegating to getSharedDrivesList) ===');
      return getSharedDrivesList();
    } else if (folderId === 'recent') {
      // 최근 항목: 최근 30일간 수정된 파일
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const dateStr = thirtyDaysAgo.toISOString();
      query = `modifiedTime > '${dateStr}' and trashed = false`;
    } else {
      query = `'${folderId}' in parents and trashed = false`;
    }
    
    // 타입 필터 추가
    if (filterType === 'spreadsheet') {
      query += " and mimeType = 'application/vnd.google-apps.spreadsheet'";
    } else if (filterType === 'folder') {
      query += " and mimeType = 'application/vnd.google-apps.folder'";
    }
    
    console.log('Step 2: Executing query:', query);
    
    // 파일 목록 가져오기 - Drive API v3 형식으로 업그레이드
    const requestParams = {
      q: query,
      pageSize: 50, // 페이지당 50개
      orderBy: folderId === 'recent' ? 'modifiedTime desc' : 'folder,name',
      fields: 'nextPageToken,files(id,name,mimeType,parents,modifiedTime)', // nextPageToken 추가
      supportsAllDrives: true,
      includeItemsFromAllDrives: true
    };
    
    // 페이지 토큰이 있으면 추가
    if (pageToken) {
      requestParams.pageToken = pageToken;
    }
    
    console.log('Step 3: Making API request with params:', requestParams);
    const response = Drive.Files.list(requestParams);
    console.log('API response:', response);
    
    if (response.files && response.files.length > 0) {
      console.log(`Step 4: Processing ${response.files.length} items`);
      response.files.forEach(file => {
        const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
        const isSpreadsheet = file.mimeType === 'application/vnd.google-apps.spreadsheet';
        
        // 필터링
        if (filterType === 'all' || 
            (filterType === 'spreadsheet' && isSpreadsheet) ||
            (filterType === 'folder' && isFolder)) {
          
          items.push({
            id: file.id,
            name: file.name,
            type: isFolder ? 'folder' : 'file',
            mimeType: file.mimeType,
            icon: getFileIcon(file), // 아이콘 함수 사용
            modifiedDate: file.modifiedTime
          });
        }
      });
    } else {
      console.log('Step 4: No items found');
    }
    
    console.log(`Step 5: Returning ${items.length} filtered items`);
    console.log('=== Function End: getDriveFolderContents SUCCESS ===');
    return { 
      success: true, 
      items, 
      folderId,
      nextPageToken: response.nextPageToken || null, // 다음 페이지 토큰
      hasMore: !!response.nextPageToken // 더 많은 결과가 있는지
    };
    
  } catch (error) {
    console.error('ERROR in getDriveFolderContents:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: getDriveFolderContents FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 폴더 경로 가져오기 (breadcrumb용)
 */
function getDrivePath(folderId) {
  console.log('=== Function Start: getDrivePath ===');
  console.log('Parameters:', { folderId });
  
  try {
    const path = [];
    let currentId = folderId;
    
    console.log('Step 1: Checking for special folder IDs');
    
    if (folderId === 'root') {
      console.log('Special case: root folder');
      console.log('=== Function End: getDrivePath SUCCESS ===');
      return { success: true, path: [{ id: 'root', name: '내 드라이브' }] };
    }
    
    if (folderId === 'sharedWithMe') {
      console.log('Special case: shared with me');
      console.log('=== Function End: getDrivePath SUCCESS ===');
      return { success: true, path: [{ id: 'sharedWithMe', name: '공유 문서함' }] };
    }
    
    if (folderId === 'sharedDrives') {
      console.log('Special case: shared drives category');
      console.log('=== Function End: getDrivePath SUCCESS ===');
      return { success: true, path: [{ id: 'sharedDrives', name: '공유 드라이브' }] };
    }
    
    if (folderId === 'recent') {
      console.log('Special case: recent items');
      console.log('=== Function End: getDrivePath SUCCESS ===');
      return { success: true, path: [{ id: 'recent', name: '최근 항목' }] };
    }
    
    console.log('Step 2: Building path for regular folder');
    
    // 폴더 경로 추적
    while (currentId && currentId !== 'root') {
      try {
        console.log('Getting file info for ID:', currentId);
        const file = Drive.Files.get(currentId, { 
          supportsAllDrives: true, // v3에서는 supportsAllDrives 사용
          fields: 'id,name,parents' // v3에서는 name 사용
        });
        console.log('File info:', { id: file.id, name: file.name, parents: file.parents });
        
        path.unshift({ id: file.id, name: file.name }); // v3에서는 name 사용
        
        if (file.parents && file.parents.length > 0) {
          currentId = file.parents[0].id;
          console.log('Moving to parent:', currentId);
        } else {
          console.log('No parent found, breaking');
          break;
        }
      } catch (e) {
        console.error('Error getting file info:', e);
        break;
      }
    }
    
    // 루트 추가
    if (currentId === 'root') {
      console.log('Step 3: Adding root to path');
      path.unshift({ id: 'root', name: '내 드라이브' });
    }
    
    console.log('Final path:', path);
    console.log('=== Function End: getDrivePath SUCCESS ===');
    return { success: true, path };
    
  } catch (error) {
    console.error('ERROR in getDrivePath:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: getDrivePath FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 파일/폴더 검색 기능 (현재 폴더 컨텍스트 내에서)
 */
function searchDriveFiles(query, filterType = 'all', currentFolderId = 'root', searchMode = 'recursive', pageToken = null) {
  console.log('=== Function Start: searchDriveFiles ===');
  console.log('Parameters:', { query, filterType, currentFolderId, searchMode });
  
  try {
    if (!query || query.trim() === '') {
      console.log('Empty query, returning empty results');
      console.log('=== Function End: searchDriveFiles SUCCESS (empty) ===');
      return { success: true, items: [], query: '' };
    }
    
    const items = [];
    let searchQuery = `name contains '${query.trim()}' and trashed = false`;
    
    // 현재 폴더 컨텍스트 추가
    console.log('Step 1: Adding folder context to search');
    if (currentFolderId === 'root') {
      // root에서 검색할 때는 parents 조건 없이 전체 검색 (내 드라이브 전체)
      // searchQuery는 이미 name contains와 trashed = false만 포함
    } else if (currentFolderId === 'sharedWithMe') {
      searchQuery += " and sharedWithMe";
    } else if (currentFolderId === 'recent') {
      // 최근 항목은 전역 검색이지만 날짜 제한 추가
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const dateStr = thirtyDaysAgo.toISOString();
      searchQuery += ` and modifiedTime > '${dateStr}'`;
    } else if (currentFolderId !== 'sharedDrives' && currentFolderId !== 'recent') {
      // 특정 폴더 내 검색 - searchMode에 따라 재귀/비재귀 결정
      if (searchMode === 'current') {
        searchQuery += ` and '${currentFolderId}' in parents`;
      }
      // recursive 모드일 때는 parents 조건 없이 전체 검색 (아래에서 필터링)
    }
    // 공유 드라이브 카테고리의 경우 별도 처리
    
    // 타입 필터 추가
    if (filterType === 'spreadsheet') {
      searchQuery += " and mimeType = 'application/vnd.google-apps.spreadsheet'";
    } else if (filterType === 'folder') {
      searchQuery += " and mimeType = 'application/vnd.google-apps.folder'";
    }
    
    console.log('Step 2: Final search query:', searchQuery);
    
    // 공유 드라이브 카테고리의 경우 별도 처리
    if (currentFolderId === 'sharedDrives') {
      console.log('Step 3: Special handling for shared drives category search');
      // 모든 공유 드라이브와 그 하위 파일들에서 검색
      try {
        const drives = Drive.Drives.list({ pageSize: 100 });
        if (drives.drives && drives.drives.length > 0) {
          // 1. 먼저 드라이브 이름이 매칭되는지 확인
          for (const drive of drives.drives) {
            if (drive.name.toLowerCase().includes(query.toLowerCase())) {
              items.push({
                id: drive.id,
                name: drive.name,
                type: 'folder',
                mimeType: 'application/vnd.google-apps.folder',
                icon: '📁',
                modifiedDate: null,
                isSharedDrive: true
              });
            }
          }
          
          // 2. 각 공유 드라이브 내부의 모든 파일/폴더에서 검색
          console.log('Searching within all shared drives...');
          for (const drive of drives.drives) {
            try {
              const driveSearchQuery = `name contains '${query.trim()}' and trashed = false`;
              const driveSearchParams = {
                q: driveSearchQuery,
                pageSize: 20, // 각 드라이브당 최대 20개
                orderBy: 'name',
                fields: 'files(id,name,mimeType,parents,modifiedTime)',
                supportsAllDrives: true,
                includeItemsFromAllDrives: true,
                driveId: drive.id,
                corpora: 'drive'
              };
              
              // 타입 필터 적용
              if (filterType === 'spreadsheet') {
                driveSearchParams.q += " and mimeType = 'application/vnd.google-apps.spreadsheet'";
              } else if (filterType === 'folder') {
                driveSearchParams.q += " and mimeType = 'application/vnd.google-apps.folder'";
              }
              
              const driveFiles = Drive.Files.list(driveSearchParams);
              if (driveFiles.files && driveFiles.files.length > 0) {
                driveFiles.files.forEach(file => {
                  const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
                  const isSpreadsheet = file.mimeType === 'application/vnd.google-apps.spreadsheet';
                  
                  items.push({
                    id: file.id,
                    name: `${file.name} (${drive.name})`, // 드라이브 이름 표시
                    type: isFolder ? 'folder' : 'file',
                    mimeType: file.mimeType,
                    icon: getFileIcon(file), // 아이콘 함수 사용
                    modifiedDate: file.modifiedTime,
                    parentDrive: drive.name
                  });
                });
              }
            } catch (e) {
              console.log(`Failed to search in drive ${drive.name}:`, e);
            }
          }
        }
      } catch (e) {
        console.error('Failed to search shared drives:', e);
      }
      
      console.log(`Step 4: Found ${items.length} total results across all shared drives`);
      console.log('=== Function End: searchDriveFiles SUCCESS (shared drives) ===');
      return { success: true, items, query: query.trim(), searchContext: 'sharedDrives' };
    }
    
    // 개별 공유 드라이브 내부 검색 처리
    console.log('Step 3: Checking if current folder is in a shared drive');
    let sharedDriveId = null;
    try {
      if (currentFolderId !== 'root' && currentFolderId !== 'sharedWithMe' && currentFolderId !== 'recent') {
        // 먼저 현재 폴더가 직접 공유 드라이브인지 확인
        const drives = Drive.Drives.list({ pageSize: 100 });
        if (drives.drives) {
          const directDrive = drives.drives.find(drive => drive.id === currentFolderId);
          if (directDrive) {
            sharedDriveId = currentFolderId;
          } else {
            // 현재 폴더가 공유 드라이브의 하위 폴더인지 확인
            const fileInfo = Drive.Files.get(currentFolderId, { 
              supportsAllDrives: true,
              fields: 'driveId'
            });
            if (fileInfo.driveId) {
              sharedDriveId = fileInfo.driveId;
            }
          }
        }
      }
    } catch (e) {
      console.log('Could not check shared drives:', e);
    }
    
    if (sharedDriveId) {
      console.log('Step 4: Searching within entire shared drive:', sharedDriveId);
      // 공유 드라이브 전체에서 검색 (parents 조건 제거)
      searchQuery = `name contains '${query.trim()}' and trashed = false`;
    }
    
    // 일반 검색 실행
    const requestParams = {
      q: searchQuery,
      pageSize: 50, // 검색 결과는 50개로 제한
      orderBy: 'name', // 이름순 정렬
      fields: 'files(id,name,mimeType,parents,modifiedTime)',
      supportsAllDrives: true,
      includeItemsFromAllDrives: true
    };
    
    // 공유 드라이브 내부 검색의 경우 driveId 지정
    if (sharedDriveId) {
      requestParams.driveId = sharedDriveId;
      requestParams.corpora = 'drive';
    }
    
    const files = Drive.Files.list(requestParams);
    console.log('Search API response:', files);
    
    if (files.files && files.files.length > 0) {
      console.log(`Step 2: Processing ${files.files.length} search results`);
      files.files.forEach(file => {
        const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
        const isSpreadsheet = file.mimeType === 'application/vnd.google-apps.spreadsheet';
        
        // 필터링
        if (filterType === 'all' || 
            (filterType === 'spreadsheet' && isSpreadsheet) ||
            (filterType === 'folder' && isFolder)) {
          
          items.push({
            id: file.id,
            name: file.name,
            type: isFolder ? 'folder' : 'file',
            mimeType: file.mimeType,
            icon: isFolder ? '📁' : (isSpreadsheet ? '<i class="fa-solid fa-file-excel"></i>' : '📄'),
            modifiedDate: file.modifiedTime
          });
        }
      });
    } else {
      console.log('Step 2: No search results found');
    }
    
    console.log(`Step 5: Returning ${items.length} filtered search results`);
    console.log('=== Function End: searchDriveFiles SUCCESS ===');
    return { success: true, items, query: query.trim(), searchContext: currentFolderId };
    
  } catch (error) {
    console.error('ERROR in searchDriveFiles:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: searchDriveFiles FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 새 폴더 만들기 - Drive API v3 사용
 */
function createNewFolder(parentFolderId, folderName) {
  console.log('=== Function Start: createNewFolder ===');
  console.log('Parameters:', { parentFolderId, folderName });
  
  try {
    if (!folderName || folderName.trim() === '') {
      console.log('Empty folder name');
      console.log('=== Function End: createNewFolder FAILED ===');
      return { success: false, error: '폴더 이름을 입력해주세요.' };
    }
    
    // 특수 위치 체크
    if (parentFolderId === 'sharedWithMe' || parentFolderId === 'recent') {
      console.log('Cannot create folder in special location');
      console.log('=== Function End: createNewFolder FAILED ===');
      return { success: false, error: '이 위치에는 폴더를 만들 수 없습니다.' };
    }
    
    if (parentFolderId === 'sharedDrives') {
      console.log('Cannot create folder at shared drives root');
      console.log('=== Function End: createNewFolder FAILED ===');
      return { success: false, error: '공유 드라이브 루트에는 폴더를 만들 수 없습니다. 특정 공유 드라이브를 선택해주세요.' };
    }
    
    console.log('Step 1: Preparing folder metadata for Drive API v3');
    
    // Drive API v3 메타데이터
    const folderMetadata = {
      name: folderName.trim(),  // v3에서는 'name' 사용 (v2의 'title' 대신)
      mimeType: 'application/vnd.google-apps.folder',
      parents: [parentFolderId === 'root' ? 'root' : parentFolderId]
    };
    
    console.log('Step 2: Folder metadata:', folderMetadata);
    
    // 공유 드라이브 체크
    let supportsAllDrives = false;
    if (parentFolderId !== 'root') {
      try {
        console.log('Step 3: Checking if parent is in shared drive');
        
        // 부모가 공유 드라이브인지 확인
        try {
          const drives = Drive.Drives.list({ pageSize: 100 });
          if (drives.drives && drives.drives.some(drive => drive.id === parentFolderId)) {
            console.log('Parent is a shared drive');
            supportsAllDrives = true;
          } else {
            // 부모 폴더가 공유 드라이브 내부인지 확인
            try {
              const parentInfo = Drive.Files.get(parentFolderId, {
                supportsAllDrives: true,
                fields: 'driveId'
              });
              if (parentInfo.driveId) {
                console.log('Parent is in shared drive:', parentInfo.driveId);
                supportsAllDrives = true;
              }
            } catch (e) {
              console.log('Parent is not in shared drive');
            }
          }
        } catch (e) {
          console.log('Could not check shared drive status:', e);
        }
      } catch (e) {
        console.log('Shared drive check skipped:', e);
      }
    }
    
    console.log('Step 4: Creating folder with Drive API v3');
    console.log('SupportsAllDrives:', supportsAllDrives);
    
    // Drive API v3로 폴더 생성
    const createdFolder = Drive.Files.create(
      folderMetadata,
      null,  // media (폴더이므로 null)
      {
        supportsAllDrives: supportsAllDrives,
        fields: 'id,name,mimeType,parents'  // v3에서는 'name' 사용
      }
    );
    
    console.log('Step 5: Folder created successfully:', createdFolder);
    
    const result = {
      success: true,
      folder: {
        id: createdFolder.id,
        name: createdFolder.name,  // v3에서는 'name' 사용
        type: 'folder',
        mimeType: createdFolder.mimeType,
        icon: '📁',
        isNew: true
      }
    };
    
    console.log('=== Function End: createNewFolder SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in createNewFolder:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: createNewFolder FAILED ===');
    
    // 더 친숙한 에러 메시지
    let errorMessage = error.toString();
    if (errorMessage.includes('Insufficient permissions')) {
      errorMessage = '이 위치에 폴더를 만들 권한이 없습니다.';
    } else if (errorMessage.includes('File not found')) {
      errorMessage = '선택한 위치를 찾을 수 없습니다.';
    }
    
    return { success: false, error: errorMessage };
  }
}

/**
 * 테스트용 - 폴더 생성 테스트
 */
function testCreateFolder() {
  try {
    console.log('=== 폴더 생성 테스트 시작 ===');
    
    // 1. 내 드라이브 루트에 테스트 폴더 생성
    const testResult = createNewFolder('root', 'TEST_FOLDER_' + new Date().getTime());
    console.log('테스트 결과:', testResult);
    
    if (testResult.success) {
      console.log('✅ 폴더 생성 성공:', testResult.folder);
      
      // 생성된 폴더 삭제
      try {
        Drive.Files.remove(testResult.folder.id);
        console.log('✅ 테스트 폴더 삭제 완료');
      } catch (e) {
        console.log('폴더 삭제 실패:', e);
      }
    } else {
      console.log('❌ 폴더 생성 실패:', testResult.error);
    }
    
    console.log('=== 폴더 생성 테스트 완료 ===');
    return testResult;
    
  } catch (error) {
    console.error('테스트 실패:', error);
    return { success: false, error: error.toString() };
  }
}

/**
 * 디버그용 - 공유 드라이브 목록 확인
 */
function testSharedDrives() {
  try {
    console.log('=== 공유 드라이브 테스트 시작 ===');
    
    // 방법 1: Drive.Drives.list (v3)
    try {
      const drives = Drive.Drives.list({ pageSize: 100 });
      console.log('Drive.Drives.list 결과:', drives);
    } catch (e) {
      console.log('Drive.Drives.list 실패:', e);
    }
    
    // 방법 2: Drive.Teamdrives.list (v2)
    try {
      const teamDrives = Drive.Teamdrives.list({ pageSize: 100 });
      console.log('Drive.Teamdrives.list 결과:', teamDrives);
    } catch (e) {
      console.log('Drive.Teamdrives.list 실패:', e);
    }
    
    // 방법 3: UrlFetch 직접 호출
    try {
      const url = 'https://www.googleapis.com/drive/v2/teamdrives';
      const response = UrlFetchApp.fetch(url, {
        headers: {
          'Authorization': 'Bearer ' + ScriptApp.getOAuthToken()
        }
      });
      console.log('UrlFetch 결과:', response.getContentText());
    } catch (e) {
      console.log('UrlFetch 실패:', e);
    }
    
    console.log('=== 공유 드라이브 테스트 완료 ===');
  } catch (error) {
    console.log('전체 테스트 실패:', error);
  }
}
