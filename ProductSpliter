/**
 * 품목별 시트 분리
 * ProductSplitter.gs
 */

const ProductSplitter = {
  /**
   * 품목별로 시트 분리
   * @param {string} targetDate - MMDD 형식의 날짜 (선택적, 없으면 자동 추출)
   */
  splitByProduct: function(targetDate) {
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      
      // 날짜 처리
      let datePrefix;
      if (targetDate) {
        // MMDD를 YYYYMMDD로 변환
        if (targetDate.length === 4) {
          datePrefix = new Date().getFullYear() + targetDate;
        } else if (targetDate.length === 8) {
          datePrefix = targetDate;
        } else {
          throw new Error('잘못된 날짜 형식입니다. MMDD 또는 YYYYMMDD 형식으로 입력하세요.');
        }
        console.log(`지정된 날짜로 품목별 시트 생성: ${datePrefix}`);
      } else {
        // 기존 시트에서 날짜 추출
        datePrefix = getTodayDate();
        const sheets = spreadsheet.getSheets();
        
        for (const sheet of sheets) {
          const name = sheet.getName();
          if ((name.includes(' 간편식 수기송장') && !name.startsWith('TEST_')) ||
              (name.includes('_간편식_수기송장') && !name.startsWith('TEST_'))) {
            datePrefix = name.split(/[ _]/)[0];
            break;
          }
        }
        console.log(`자동 추출된 날짜로 품목별 시트 생성: ${datePrefix}`);
      }
      
      const sourceSheetName = datePrefix + '_간편식_수기송장';
      const sourceSheetNameOld = datePrefix + ' 간편식 수기송장'; // 기존 형식 호환
      
      let sourceSheet = spreadsheet.getSheetByName(sourceSheetName);
      
      // 새 형식이 없으면 기존 형식 시도
      if (!sourceSheet) {
        sourceSheet = spreadsheet.getSheetByName(sourceSheetNameOld);
      }
      
      if (!sourceSheet) {
        return {
          success: false,
          error: '수기송장 시트를 찾을 수 없습니다: ' + sourceSheetName + ' 또는 ' + sourceSheetNameOld
        };
      }
      
      // 데이터 가져오기
      const data = sourceSheet.getDataRange().getValues();
      if (data.length < 2) {
        return {
          success: false,
          error: '데이터가 없습니다.'
        };
      }
      
      const headers = data[0];
      const rows = data.slice(1);
      
      // 품목명 열 찾기
      let productColIndex = -1;
      for (let i = 0; i < headers.length; i++) {
        if (headers[i] === '품목명' || headers[i] === 'N') {
          productColIndex = i;
          break;
        }
      }
      
      if (productColIndex === -1) {
        // N열(14번째 열, 인덱스 13) 사용
        productColIndex = 13;
      }
      
      // 품목별로 데이터 그룹화
      const productGroups = this.groupByProduct(rows, productColIndex);
      
      // 각 품목별로 시트 생성
      const createdSheets = [];
      for (const [productKey, productData] of Object.entries(productGroups)) {
        const sheetName = this.createProductSheet(
          spreadsheet, 
          productKey, 
          productData.name, 
          headers, 
          productData.rows,
          datePrefix
        );
        createdSheets.push(sheetName);
      }
      
      return {
        success: true,
        sheets: createdSheets
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.toString()
      };
    }
  },
  
  /**
   * 품목별로 데이터 그룹화
   */
  groupByProduct: function(rows, productColIndex) {
    const groups = {};
    
    for (const row of rows) {
      const productName = String(row[productColIndex] || '').trim();
      if (!productName) continue;
      
      // 품목 키 결정
      let productKey = '';
      let displayName = productName;
      
      if (productName.includes('사골고기곰탕')) {
        productKey = '사골고기곰탕';
        displayName = '사골고기곰탕';
      } else if (productName.includes('사골곰탕')) {
        productKey = '사골곰탕';
        displayName = '사골곰탕';
      } else if (productName.includes('육포')) {
        productKey = '육포';
        displayName = '육포';
      } else {
        // 기타 품목은 전체 이름 사용
        productKey = productName;
        displayName = productName;
      }
      
      if (!groups[productKey]) {
        groups[productKey] = {
          name: displayName,
          rows: []
        };
      }
      
      groups[productKey].rows.push(row);
    }
    
    return groups;
  },
  
  /**
   * 품목별 시트 생성 (템플릿 시트 복사 사용)
   */
  createProductSheet: function(spreadsheet, productKey, productName, headers, rows, datePrefix) {
    console.log('=== Product Sheet Creation Start ===');
    console.log('Parameters:', { productKey, productName, datePrefix, rowCount: rows.length });
    
    const sheetName = datePrefix + '_' + productName;
    
    // 기존 시트 삭제
    let sheet = spreadsheet.getSheetByName(sheetName);
    if (sheet) {
      console.log('Deleting existing sheet:', sheetName);
      spreadsheet.deleteSheet(sheet);
    }
    
    // 템플릿 시트 복사 또는 새 시트 생성
    const templateSheet = spreadsheet.getSheetByName(CONFIG.MANUAL_TEMPLATE_SHEET_NAME);
    if (templateSheet) {
      console.log('Using template sheet:', CONFIG.MANUAL_TEMPLATE_SHEET_NAME);
      sheet = templateSheet.copyTo(spreadsheet);
      sheet.setName(sheetName);
      
      // 기존 데이터 삭제 (헤더 제외)
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        console.log('Clearing existing data from row 2 to', lastRow);
        sheet.deleteRows(2, lastRow - 1);
      }
    } else {
      console.log('Template sheet not found, creating new sheet');
      sheet = spreadsheet.insertSheet(sheetName);
      
      // 헤더 설정
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      
      // 기본 서식 설정
      sheet.getRange(1, 1, 1, headers.length)
        .setBackground('#4285f4')
        .setFontColor('#ffffff')
        .setFontWeight('bold');
    }
    
    // 데이터 입력
    if (rows.length > 0) {
      console.log('Adding', rows.length, 'rows of data');
      const dataRange = sheet.getRange(2, 1, rows.length, rows[0].length);
      dataRange.setValues(rows);
      
      // 숫자 열들 오른쪽 정렬 (템플릿 사용 시에도 적용)
      this.applyNumberFormatting(sheet, rows.length);
    }
    
    // 열 크기 자동 조정
    sheet.autoResizeColumns(1, headers.length);
    
    console.log('=== Product Sheet Creation Complete ===');
    return sheetName;
  },
  
  /**
   * 숫자 데이터 오른쪽 정렬 및 H열 전화번호 복사
   */
  applyNumberFormatting: function(sheet, rowCount) {
    console.log('=== Number Formatting & Phone Copy Start ===');
    console.log('Sheet:', sheet.getName(), 'Rows:', rowCount);
    
    if (rowCount === 0) return;
    
    try {
      // H열 "받으시는 분 전화"에 J열 "받는분핸드폰" 데이터 복사
      const jColumnData = sheet.getRange(2, 10, rowCount, 1).getValues(); // J열 데이터 읽기
      sheet.getRange(2, 8, rowCount, 1).setValues(jColumnData); // H열에 복사
      console.log('Copied phone data from column J to column H (받으시는 분 전화)');
      
      // B열: 보내시는 분 전화
      const phoneRange = sheet.getRange(2, 2, rowCount, 1);
      phoneRange.setHorizontalAlignment('right');
      console.log('Applied right alignment to column B (보내시는 분 전화)');
      
      // H열: 받으시는 분 전화 (복사된 데이터)
      const receiverPhoneRange = sheet.getRange(2, 8, rowCount, 1);
      receiverPhoneRange.setHorizontalAlignment('right');
      console.log('Applied right alignment to column H (받으시는 분 전화)');
      
      // J열: 받는분핸드폰
      const cellRange = sheet.getRange(2, 10, rowCount, 1);
      cellRange.setHorizontalAlignment('right');
      console.log('Applied right alignment to column J (받는분핸드폰)');
      
      // K열: 받는분우편번호
      const postalRange = sheet.getRange(2, 11, rowCount, 1);
      postalRange.setHorizontalAlignment('right');
      console.log('Applied right alignment to column K (받는분우편번호)');
      
      // M열: 수량
      const quantityRange = sheet.getRange(2, 13, rowCount, 1);
      quantityRange.setHorizontalAlignment('right');
      quantityRange.setNumberFormat('#,##0'); // 천 단위 구분자 적용
      console.log('Applied right alignment and number format to column M (수량)');
      
      console.log('=== Number Formatting & Phone Copy Complete ===');
    } catch (error) {
      console.error('Formatting and phone copy failed:', error);
    }
  }
};
