/**
 * 쿠팡 데이터 처리
 * CoupangProcessor.gs
 */

const CoupangProcessor = {
  /**
   * 쿠팡 엑셀 파일 처리 (HTML에서 호출)
   */
  processCoupangFile: function(fileData, fileName) {
    try {
      // Base64 디코딩
      const blob = Utilities.newBlob(Utilities.base64Decode(fileData), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', fileName);
      
      // 임시 파일로 저장
      const tempFile = DriveApp.createFile(blob);
      tempFile.setName('temp_coupang_' + fileName);
      
      // Google Sheets로 변환
      const todayFull = getTodayDate();
      const resource = {
        title: todayFull + '_간편식_쿠팡',
        mimeType: MimeType.GOOGLE_SHEETS
      };
      
      const fileId = tempFile.getId();
      const convertedFile = Drive.Files.copy(resource, fileId);
      
      // 임시 파일 삭제
      DriveApp.getFileById(fileId).setTrashed(true);
      
      // 변환된 스프레드시트 열기
      const coupangSpreadsheet = SpreadsheetApp.openById(convertedFile.id);
      const deliverySheet = coupangSpreadsheet.getSheetByName('Delivery') || coupangSpreadsheet.getSheets()[0];
      
      // 데이터 읽기
      const coupangData = deliverySheet.getDataRange().getValues();
      
      // 쿠팡 데이터를 수기송장에 추가
      const result = this.addCoupangDataToManualInvoice(coupangData);
      
      // 드라이브 폴더로 이동
      this.moveCoupangFileToFolder(convertedFile.id, todayFull);
      
      return result;
      
    } catch (error) {
      return {
        success: false,
        error: error.toString()
      };
    }
  },
  
  /**
   * 쿠팡 데이터를 수기송장에 추가 (디버깅 강화)
   */
  addCoupangDataToManualInvoice: function(coupangData) {
    try {
      console.log('=== 쿠팡 데이터 수기송장 추가 시작 ===');
      console.log(`총 데이터 행 수: ${coupangData.length}`);
      
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      
      // 날짜 추출
      let datePrefix = getTodayDate();
      const sheets = spreadsheet.getSheets();
      
      for (const sheet of sheets) {
        const name = sheet.getName();
        if ((name.includes('_간편식_수기송장') || name.includes(' 간편식 수기송장')) && !name.startsWith('TEST_')) {
          datePrefix = name.split(/[ _]/)[0];
          break;
        }
      }
      
      const manualSheetName = datePrefix + '_간편식_수기송장';
      const manualSheetNameOld = datePrefix + ' 간편식 수기송장'; // 기존 형식 호환
      
      let manualSheet = spreadsheet.getSheetByName(manualSheetName);
      
      // 새 형식이 없으면 기존 형식 시도
      if (!manualSheet) {
        manualSheet = spreadsheet.getSheetByName(manualSheetNameOld);
      }
      
      if (!manualSheet) {
        throw new Error('수기송장 시트를 찾을 수 없습니다: ' + manualSheetName + ' 또는 ' + manualSheetNameOld);
      }
      
      console.log(`✅ 수기송장 시트 발견: ${manualSheet.getName()}`);
      
      // 쿠팡 데이터 헤더와 열 매핑
      const coupangHeaders = coupangData[0];
      const coupangRows = coupangData.slice(1);
      const coupangMapping = this.getCoupangColumnMapping(coupangHeaders);
      
      // 수기송장 헤더 매핑
      const manualHeaders = manualSheet.getRange(1, 1, 1, manualSheet.getLastColumn()).getValues()[0];
      const manualMapping = this.getManualColumnMapping(manualHeaders);
      
      console.log(`처리할 쿠팡 데이터 행 수: ${coupangRows.length}`);
      
      // 변환된 데이터 생성
      const newRows = [];
      let processedCount = 0;
      let skippedCount = 0;
      
      for (let i = 0; i < coupangRows.length; i++) {
        const row = coupangRows[i];
        console.log(`\n--- 행 ${i + 1} 처리 중 ---`);
        
        const productName = row[coupangMapping.productName];
        const quantity = row[coupangMapping.quantity];
        
        console.log(`상품명: "${productName}"`);
        console.log(`수량: "${quantity}"`);
        
        if (!productName) {
          console.log(`❌ 건너뛰기: 상품명 없음`);
          skippedCount++;
          continue;
        }
        
        const convertedRow = this.convertCoupangRow(row, coupangMapping, manualHeaders.length);
        if (convertedRow) {
          newRows.push(convertedRow);
          processedCount++;
          console.log(`✅ 행 처리 완료`);
        } else {
          console.log(`❌ 건너뛰기: 변환 실패`);
          skippedCount++;
        }
      }
      
      console.log(`\n=== 처리 결과 ===`);
      console.log(`성공: ${processedCount}개`);
      console.log(`건너뛰기: ${skippedCount}개`);
      console.log(`추가할 행: ${newRows.length}개`);
      
      // 수기송장에 데이터 추가
      if (newRows.length > 0) {
        const lastRow = manualSheet.getLastRow();
        console.log(`수기송장 ${lastRow + 1}번째 행부터 ${newRows.length}개 행 추가`);
        
        manualSheet.getRange(lastRow + 1, 1, newRows.length, newRows[0].length).setValues(newRows);
        
        // 검산결과 시트 업데이트
        const verificationUpdate = this.updateVerificationSheetWithCoupang(datePrefix, coupangRows, coupangMapping);
        console.log('검산결과 시트 업데이트 결과:', verificationUpdate);
      }
      
      return {
        success: true,
        rowsAdded: newRows.length,
        processedCount: processedCount,
        skippedCount: skippedCount,
        message: `쿠팡 데이터 ${newRows.length}행이 추가되었습니다. (처리: ${processedCount}, 건너뛰기: ${skippedCount})`
      };
      
    } catch (error) {
      console.error('addCoupangDataToManualInvoice 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  },
  
  /**
   * 쿠팡 열 매핑 (개선된 버전)
   */
  getCoupangColumnMapping: function(headers) {
    const mapping = {};
    
    console.log('=== 쿠팡 헤더 분석 시작 ===');
    console.log('전체 헤더:', headers);
    
    // 헤더로 찾기
    headers.forEach((header, index) => {
      const cleanHeader = String(header).trim();
      console.log(`Index ${index} (${String.fromCharCode(65 + index)}열): "${cleanHeader}"`);
      
      // M열(12) 또는 P열(15): 상품명 - 더 포괄적인 매칭
      if (index === 12 || index === 15 || 
          cleanHeader.includes('노출상품명') || 
          cleanHeader.includes('최초등록상품명') ||
          cleanHeader.includes('상품명') ||
          cleanHeader.includes('제동한우')) {
        // 우선순위: P열 > M열 > 기타
        if (!mapping.productName || index === 15) {
          mapping.productName = index;
          console.log(`✅ 상품명 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열) - "${cleanHeader}"`);
        }
      }
      
      // W열(22): 구매수(수량) - 더 포괄적인 매칭
      if (index === 22 || 
          cleanHeader === '구매수' || 
          cleanHeader === '수량' ||
          cleanHeader.includes('구매수') ||
          cleanHeader.includes('수량')) {
        mapping.quantity = index;
        console.log(`✅ 수량 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열) - "${cleanHeader}"`);
      }
      
      // Y열(24): 구매자
      if (index === 24 || cleanHeader === '구매자') {
        mapping.buyer = index;
        console.log(`✅ 구매자 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
      
      // Z열(25): 구매자전화번호
      if (index === 25 || cleanHeader === '구매자전화번호') {
        mapping.buyerPhone = index;
        console.log(`✅ 구매자전화 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
      
      // AA열(26): 수취인이름
      if (index === 26 || cleanHeader === '수취인이름' || cleanHeader === '수취인') {
        mapping.receiverName = index;
        console.log(`✅ 수취인 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
      
      // AB열(27): 수취인전화번호
      if (index === 27 || cleanHeader === '수취인전화번호') {
        mapping.receiverPhone = index;
        console.log(`✅ 수취인전화 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
      
      // AC열(28): 우편번호
      if (index === 28 || cleanHeader === '우편번호') {
        mapping.postalCode = index;
        console.log(`✅ 우편번호 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
      
      // AD열(29): 수취인 주소
      if (index === 29 || (cleanHeader.includes('수취인') && cleanHeader.includes('주소'))) {
        mapping.address = index;
        console.log(`✅ 주소 컬럼 설정: ${index}번째 (${String.fromCharCode(65 + index)}열)`);
      }
    });
    
    // 인덱스로 보정 (헤더를 못 찾았을 경우)
    if (!mapping.productName) {
      mapping.productName = 15; // P열 기본값
      console.log(`⚠️ 상품명 컬럼 기본값 사용: P열(15)`);
    }
    if (!mapping.quantity) {
      mapping.quantity = 22; // W열 기본값
      console.log(`⚠️ 수량 컬럼 기본값 사용: W열(22)`);
    }
    if (!mapping.buyer) mapping.buyer = 24; // Y열
    if (!mapping.buyerPhone) mapping.buyerPhone = 25; // Z열
    if (!mapping.receiverName) mapping.receiverName = 26; // AA열
    if (!mapping.receiverPhone) mapping.receiverPhone = 27; // AB열
    if (!mapping.postalCode) mapping.postalCode = 28; // AC열
    if (!mapping.address) mapping.address = 29; // AD열
    
    console.log('=== 최종 컬럼 매핑 ===');
    console.log(JSON.stringify(mapping, null, 2));
    
    return mapping;
  },
  
  /**
   * 수기송장 열 매핑
   */
  getManualColumnMapping: function(headers) {
    const mapping = {};
    
    headers.forEach((header, index) => {
      if (header === '보내시는 분') mapping.senderName = index;
      if (header === '보내시는 분 전화') mapping.senderPhone = index;
      if (header === '받으시는 분') mapping.receiverName = index;
      if (header === '받으시는 분 전화') mapping.receiverPhone1 = index;
      if (header === '받는분핸드폰') mapping.receiverPhone2 = index;
      if (header === '받는분우편번호') mapping.postalCode = index;
      if (header === '받는분총주소') mapping.address = index;
      if (header === '수량') mapping.quantity = index;
      if (header === '품목명') mapping.productName = index;
    });
    
    // 기본값 설정 (찾지 못한 경우)
    if (mapping.senderName === undefined) mapping.senderName = 0; // A열
    if (mapping.senderPhone === undefined) mapping.senderPhone = 1; // B열
    if (mapping.receiverName === undefined) mapping.receiverName = 6; // G열
    if (mapping.receiverPhone1 === undefined) mapping.receiverPhone1 = 7; // H열
    if (mapping.receiverPhone2 === undefined) mapping.receiverPhone2 = 9; // J열
    if (mapping.postalCode === undefined) mapping.postalCode = 10; // K열
    if (mapping.address === undefined) mapping.address = 11; // L열
    if (mapping.quantity === undefined) mapping.quantity = 12; // M열
    if (mapping.productName === undefined) mapping.productName = 13; // N열
    
    return mapping;
  },
  
  /**
   * 쿠팡 행 변환 (개선된 버전)
   */
  convertCoupangRow: function(coupangRow, coupangMapping, numColumns) {
    const productNameRaw = String(coupangRow[coupangMapping.productName] || '');
    const quantityRaw = coupangRow[coupangMapping.quantity];
    
    console.log(`=== 상품 변환 시도 ===`);
    console.log(`원본 상품명: "${productNameRaw}"`);
    console.log(`원본 수량: "${quantityRaw}"`);
    
    // 상품명 변환 (더 유연한 매칭)
    let convertedProductName = '';
    
    // 패턴 1: 사골고기곰탕 5개입
    if ((productNameRaw.includes('사골고기곰탕') || productNameRaw.includes('사골고기 곰탕')) && 
        (productNameRaw.includes('5개') || productNameRaw.includes('5팩'))) {
      convertedProductName = '제동 사골고기곰탕(5팩 1세트)';
    }
    // 패턴 2: 사골곰탕 20개입
    else if (productNameRaw.includes('사골곰탕') && !productNameRaw.includes('사골고기') &&
             (productNameRaw.includes('20개') || productNameRaw.includes('20팩'))) {
      convertedProductName = '제동 사골곰탕(20팩 1세트)';
    }
    // 패턴 3: 사골곰탕 10개입
    else if (productNameRaw.includes('사골곰탕') && !productNameRaw.includes('사골고기') &&
             (productNameRaw.includes('10개') || productNameRaw.includes('10팩'))) {
      convertedProductName = '제동 사골곰탕(10팩 1세트)';
    }
    // 패턴 4: 사골곰탕 5개입 (기본)
    else if (productNameRaw.includes('사골곰탕') && !productNameRaw.includes('사골고기') &&
             (productNameRaw.includes('5개') || productNameRaw.includes('5팩') || 
              (!productNameRaw.includes('10개') && !productNameRaw.includes('20개')))) {
      convertedProductName = '제동 사골곰탕(5팩 1세트)';
    }
    // 패턴 5: 육포 5개입
    else if (productNameRaw.includes('육포') && 
             (productNameRaw.includes('5개') || productNameRaw.includes('5팩'))) {
      convertedProductName = '제동한우 육포(5팩 1세트)';
    }
    else {
      // 변환할 수 없는 상품은 건너뛰기
      console.log(`❌ 변환 실패: "${productNameRaw}" - 알 수 없는 상품 형식`);
      return null;
    }
    
    console.log(`✅ 변환 성공: "${productNameRaw}" → "${convertedProductName}"`);
    
    // 새 행 생성
    const newRow = new Array(numColumns).fill('');
    
    newRow[0] = coupangRow[coupangMapping.buyer] || ''; // A: 보내시는 분
    newRow[1] = coupangRow[coupangMapping.buyerPhone] || ''; // B: 보내시는 분 전화
    newRow[4] = CONFIG.SENDER_POSTAL_CODE; // E: 보내는분우편번호
    newRow[5] = CONFIG.SENDER_ADDRESS; // F: 보내는분총주소
    newRow[6] = coupangRow[coupangMapping.receiverName] || ''; // G: 받으시는 분
    newRow[7] = coupangRow[coupangMapping.receiverPhone] || ''; // H: 받으시는 분 전화
    newRow[9] = coupangRow[coupangMapping.receiverPhone] || ''; // J: 받는분핸드폰
    newRow[10] = coupangRow[coupangMapping.postalCode] || ''; // K: 받는분우편번호
    newRow[11] = coupangRow[coupangMapping.address] || ''; // L: 받는분총주소
    newRow[12] = coupangRow[coupangMapping.quantity] || 0; // M: 수량
    newRow[13] = convertedProductName; // N: 품목명
    newRow[18] = '쿠팡'; // S: 메모1 (쿠팡 마킹)
    
    console.log(`✅ 행 변환 완료: 상품="${convertedProductName}", 수량=${newRow[12]}, 받는분="${newRow[6]}"`);
    
    return newRow;
  },
  
  /**
   * 쿠팡 파일을 날짜 폴더로 이동
   */
  moveCoupangFileToFolder: function(fileId, dateString) {
    try {
      const file = DriveApp.getFileById(fileId);
      const parentFolderId = CONFIG.FOLDER_ID;
      const parentFolder = DriveApp.getFolderById(parentFolderId);
      
      // 날짜 폴더 찾기 또는 생성
      const folders = parentFolder.getFoldersByName(dateString);
      let dateFolder;
      
      if (folders.hasNext()) {
        dateFolder = folders.next();
      } else {
        dateFolder = parentFolder.createFolder(dateString);
      }
      
      // 파일 이동
      dateFolder.addFile(file);
      DriveApp.getRootFolder().removeFile(file);
      
    } catch (error) {
      console.error('쿠팡 파일 이동 실패:', error);
    }
  },

  /**
   * 검산결과 시트에 쿠팡 데이터 업데이트
   */
  updateVerificationSheetWithCoupang: function(datePrefix, coupangRows, coupangMapping) {
    console.log('=== 검산결과 시트 쿠팡 데이터 업데이트 시작 ===');
    
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const verificationSheetName = `${datePrefix}_검산결과`;
      let verificationSheet = spreadsheet.getSheetByName(verificationSheetName);
      
      if (!verificationSheet) {
        console.log(`⚠️ 검산결과 시트 없음: ${verificationSheetName}`);
        return { success: false, error: `검산결과 시트를 찾을 수 없습니다: ${verificationSheetName}` };
      }
      
      console.log(`✅ 검산결과 시트 발견: ${verificationSheetName}`);
      
      // H열과 I열 헤더 추가/확인 및 스타일링
      const headerRow = verificationSheet.getRange(1, 1, 1, Math.max(verificationSheet.getLastColumn(), 9)).getValues()[0];
      
      // H열(7)에 "쿠팡" 헤더가 없으면 추가
      if (!headerRow[7] || String(headerRow[7]).trim() !== '쿠팡') {
        const headerCell = verificationSheet.getRange(1, 8);
        headerCell.setValue('쿠팡');
        
        // 기존 헤더 스타일과 일치시키기
        const existingHeaderStyle = verificationSheet.getRange(1, 1);
        headerCell.setBackground(existingHeaderStyle.getBackground());
        headerCell.setFontColor(existingHeaderStyle.getFontColor());
        headerCell.setFontWeight(existingHeaderStyle.getFontWeight());
        headerCell.setHorizontalAlignment('center');
        headerCell.setBorder(true, true, true, true, false, false);
        
        console.log('H열에 "쿠팡" 헤더 추가 (스타일 적용)');
      }
      
      // I열(8)에 "MMDD 출고수량" 헤더가 없으면 추가
      const mmdd = datePrefix.substring(4); // YYYYMMDD에서 MMDD 추출
      const expectedHeader = `${mmdd} 출고수량`;
      if (!headerRow[8] || String(headerRow[8]).trim() !== expectedHeader) {
        const headerCell = verificationSheet.getRange(1, 9);
        headerCell.setValue(expectedHeader);
        
        // 기존 헤더 스타일과 일치시키기
        const existingHeaderStyle = verificationSheet.getRange(1, 1);
        headerCell.setBackground(existingHeaderStyle.getBackground());
        headerCell.setFontColor(existingHeaderStyle.getFontColor());
        headerCell.setFontWeight(existingHeaderStyle.getFontWeight());
        headerCell.setHorizontalAlignment('center');
        headerCell.setBorder(true, true, true, true, false, false);
        
        console.log(`I열에 "${expectedHeader}" 헤더 추가 (스타일 적용)`);
      }
      
      // 쿠팡 제품별 수량 계산
      const coupangProductQuantities = {};
      
      for (const row of coupangRows) {
        const productName = String(row[coupangMapping.productName] || '').trim();
        const quantity = parseInt(row[coupangMapping.quantity] || 0);
        
        if (productName && quantity > 0) {
          console.log(`쿠팡 제품 발견: "${productName}" / 수량=${quantity}`);
          
          // 제품명 정규화
          const normalizedProduct = this.normalizeCoupangProductName(productName);
          if (normalizedProduct) {
            if (!coupangProductQuantities[normalizedProduct]) {
              coupangProductQuantities[normalizedProduct] = 0;
            }
            coupangProductQuantities[normalizedProduct] += quantity;
            console.log(`정규화: "${productName}" → "${normalizedProduct}" (+${quantity})`);
          } else {
            console.log(`⚠️ 제품명 정규화 실패: "${productName}"`);
          }
        }
      }
      
      console.log('쿠팡 제품별 수량:', JSON.stringify(coupangProductQuantities, null, 2));
      
      // 검산결과 시트에서 모든 제품에 대해 총 출고수량 계산
      const data = verificationSheet.getDataRange().getValues();
      let updatedCount = 0;
      
      for (let i = 1; i < data.length; i++) { // 헤더 제외
        const row = data[i];
        const verificationProductName = String(row[1] || '').trim(); // B열: 품목명
        
        if (verificationProductName) {
          // F열(5): 싸이버스카이 합계 수량 읽기
          const cyberskyQuantity = parseInt(row[5] || 0);
          
          // 쿠팡 수량 확인
          const normalizedVerificationProduct = this.normalizeCoupangProductName(verificationProductName);
          const coupangQuantity = (normalizedVerificationProduct && coupangProductQuantities[normalizedVerificationProduct]) 
            ? coupangProductQuantities[normalizedVerificationProduct] : 0;
          
          // 총 출고수량 계산
          const totalQuantity = cyberskyQuantity + coupangQuantity;
          
          // H열(7)에 쿠팡 수량 설정 (0이어도 설정)
          verificationSheet.getRange(i + 1, 8).setValue(coupangQuantity);
          
          // I열(8)에 총 출고수량 설정 (모든 행에 설정)
          verificationSheet.getRange(i + 1, 9).setValue(totalQuantity);
          
          console.log(`업데이트: "${verificationProductName}" | 싸이버스카이: ${cyberskyQuantity} + 쿠팡: ${coupangQuantity} = 총: ${totalQuantity}`);
          updatedCount++;
        }
      }
      
      // 검산결과 시트에 없는 쿠팡 제품들 새로 추가
      const newProductsToAdd = [];
      for (const [productName, quantity] of Object.entries(coupangProductQuantities)) {
        let found = false;
        
        // 기존 행에서 찾기
        for (let i = 1; i < data.length; i++) {
          const verificationProductName = String(data[i][1] || '').trim();
          const normalizedVerificationProduct = this.normalizeCoupangProductName(verificationProductName);
          
          if (normalizedVerificationProduct === productName) {
            found = true;
            break;
          }
        }
        
        // 없으면 새로 추가할 목록에 포함
        if (!found) {
          const displayName = this.getDisplayNameFromNormalized(productName);
          newProductsToAdd.push([
            '', // A열: 빈값
            displayName, // B열: 품목명
            '', '', '', '', '', // C~G열: 빈값들
            quantity, // H열: 쿠팡 수량
            quantity // I열: 총 출고수량 (쿠팡만)
          ]);
          console.log(`새 제품 추가: "${displayName}" | 쿠팡: ${quantity}`);
        }
      }
      
      // 새 제품들을 정렬된 위치에 삽입
      if (newProductsToAdd.length > 0) {
        this.insertNewProductsInSortedOrder(verificationSheet, newProductsToAdd);
        console.log(`${newProductsToAdd.length}개 신규 쿠팡 제품을 정렬된 위치에 추가`);
      }
      
      const totalProcessed = updatedCount + newProductsToAdd.length;
      console.log(`✅ 검산결과 시트 업데이트 완료: 기존 ${updatedCount}개 업데이트, 신규 ${newProductsToAdd.length}개 추가`);
      
      return {
        success: true,
        updatedCount: updatedCount,
        newProductsAdded: newProductsToAdd.length,
        totalProcessed: totalProcessed,
        message: `검산결과 시트 업데이트 완료 (업데이트: ${updatedCount}, 신규: ${newProductsToAdd.length})`
      };
      
    } catch (error) {
      console.error('검산결과 시트 업데이트 실패:', error);
      return {
        success: false,
        error: error.toString()
      };
    }
  },

  /**
   * 쿠팡 제품명 정규화
   */
  normalizeCoupangProductName: function(productName) {
    if (productName.includes('사골고기곰탕')) {
      return '사골고기곰탕5개입';
    }
    else if (productName.includes('사골곰탕') && (productName.includes('20팩') || productName.includes('20개입'))) {
      return '사골곰탕20개입';
    }
    else if (productName.includes('사골곰탕') && (productName.includes('10팩') || productName.includes('10개입'))) {
      return '사골곰탕10개입';
    }
    else if (productName.includes('사골곰탕') && !productName.includes('사골고기곰탕') && 
            (productName.includes('5팩') || productName.includes('5개입') || productName.includes('1박스'))) {
      return '사골곰탕5개입';
    }
    else if (productName.includes('육포')) {
      return '육포5개입';
    }
    
    return null;
  },

  /**
   * 정규화된 제품명을 표시용 이름으로 변환 (괄호 앞 공백 포함)
   */
  getDisplayNameFromNormalized: function(normalizedName) {
    const displayMap = {
      '사골고기곰탕5개입': '제동 사골고기곰탕 (5팩 1세트)',
      '사골곰탕5개입': '제동 사골곰탕 (5팩 1세트)',
      '사골곰탕10개입': '제동 사골곰탕 (10팩 1세트)',
      '사골곰탕20개입': '제동 사골곰탕 (20팩 1세트)',
      '육포5개입': '제동한우 육포 (5팩 1세트)'
    };
    
    return displayMap[normalizedName] || normalizedName;
  },

  /**
   * 제품 타입에 따른 정렬 우선순위 반환
   */
  getProductSortPriority: function(normalizedName) {
    const priorities = {
      '사골고기곰탕5개입': 1,
      '사골곰탕5개입': 2,
      '사골곰탕10개입': 3,
      '사골곰탕20개입': 4,
      '육포5개입': 5
    };
    
    return priorities[normalizedName] || 999;
  },

  /**
   * 새 쿠팡 제품을 정렬된 위치에 삽입
   */
  insertNewProductsInSortedOrder: function(verificationSheet, newProductsToAdd) {
    console.log('=== 정렬된 위치에 새 제품 삽입 시작 ===');
    
    if (newProductsToAdd.length === 0) {
      console.log('추가할 제품 없음');
      return;
    }
    
    // 새 제품들을 우선순위에 따라 정렬
    newProductsToAdd.sort((a, b) => {
      const normalizedA = this.normalizeCoupangProductName(a[1]);
      const normalizedB = this.normalizeCoupangProductName(b[1]);
      const priorityA = this.getProductSortPriority(normalizedA);
      const priorityB = this.getProductSortPriority(normalizedB);
      return priorityA - priorityB;
    });
    
    const data = verificationSheet.getDataRange().getValues();
    let insertedCount = 0;
    
    for (const newProduct of newProductsToAdd) {
      const newProductNormalized = this.normalizeCoupangProductName(newProduct[1]);
      const newProductPriority = this.getProductSortPriority(newProductNormalized);
      
      // 삽입할 위치 찾기
      let insertRowIndex = data.length; // 기본값: 맨 아래
      
      for (let i = 1; i < data.length; i++) { // 헤더 제외
        const existingProductName = String(data[i][1] || '').trim();
        if (!existingProductName) continue;
        
        const existingNormalized = this.normalizeCoupangProductName(existingProductName);
        const existingPriority = this.getProductSortPriority(existingNormalized);
        
        if (newProductPriority < existingPriority) {
          insertRowIndex = i;
          break;
        } else if (newProductPriority === existingPriority) {
          // 같은 타입이면 그 그룹의 마지막 위치에 삽입
          let j = i;
          while (j < data.length && 
                 this.getProductSortPriority(this.normalizeCoupangProductName(String(data[j][1] || '').trim())) === existingPriority) {
            j++;
          }
          insertRowIndex = j;
          break;
        }
      }
      
      console.log(`"${newProduct[1]}" 제품을 ${insertRowIndex + 1}번째 행에 삽입`);
      
      // 행 삽입
      verificationSheet.insertRowAfter(insertRowIndex);
      
      // 데이터 입력
      verificationSheet.getRange(insertRowIndex + 1, 1, 1, newProduct.length).setValues([newProduct]);
      
      // data 배열도 업데이트 (다음 삽입을 위해)
      data.splice(insertRowIndex, 0, newProduct);
      insertedCount++;
    }
    
    console.log(`✅ ${insertedCount}개 제품을 정렬된 위치에 삽입 완료`);
  }
};

/**
 * 현재 작업 중인 날짜 가져오기 (저장된 날짜 우선, 없으면 시트명에서 추출)
 */
function getCurrentWorkingDate() {
  try {
    // 1. 저장된 작업 날짜 확인 (통합 워크플로우에서 설정)
    const savedDate = PropertiesService.getScriptProperties().getProperty('CURRENT_WORKING_DATE');
    if (savedDate) {
      console.log(`저장된 작업 날짜 사용: ${savedDate}`);
      return savedDate;
    }
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheets = spreadsheet.getSheets();
    
    // 2. 수기송장 시트에서 날짜 추출
    for (const sheet of sheets) {
      const name = sheet.getName();
      if (name.includes('_간편식_수기송장') && !name.startsWith('TEST_')) {
        const datePart = name.split('_')[0];
        if (datePart.length === 8 && /^\d{8}$/.test(datePart)) {
          const mmdd = datePart.substring(4); // YYYYMMDD에서 MMDD 추출
          console.log(`수기송장 시트에서 날짜 추출: ${mmdd}`);
          return mmdd;
        }
      }
    }
    
    // 3. 검산결과 시트에서 날짜 추출
    for (const sheet of sheets) {
      const name = sheet.getName();
      if (name.includes('_검산결과') && !name.startsWith('TEST_')) {
        const datePart = name.split('_')[0];
        if (datePart.length === 8 && /^\d{8}$/.test(datePart)) {
          const mmdd = datePart.substring(4); // YYYYMMDD에서 MMDD 추출
          console.log(`검산결과 시트에서 날짜 추출: ${mmdd}`);
          return mmdd;
        }
      }
    }
    
    // 4. 기본값: 오늘 날짜
    const todayDate = getTodayShortDate();
    console.log(`기본값으로 오늘 날짜 사용: ${todayDate}`);
    return todayDate;
    
  } catch (error) {
    console.error('getCurrentWorkingDate 오류:', error);
    return getTodayShortDate();
  }
}

/**
 * HTML에서 호출할 전역 함수 (CoupangUploader용)
 */
function processCoupangFile(fileData, fileName) {
  console.log('=== Function Start: processCoupangFile ===');
  console.log('Parameters:', { fileName });
  
  try {
    const result = CoupangProcessor.processCoupangFile(fileData, fileName);
    console.log('Processing result:', result);
    console.log('=== Function End: processCoupangFile SUCCESS ===');
    return result;
    
  } catch (error) {
    console.error('ERROR in processCoupangFile:', error.toString());
    console.error('Error stack:', error.stack);
    console.log('=== Function End: processCoupangFile FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 쿠팡 파일 처리 후 자동으로 나머지 과정 실행 (통합 워크플로우용)
 * @param {string} fileData - Base64 인코딩된 파일 데이터
 * @param {string} fileName - 파일명
 * @param {string} targetDate - MMDD 형식의 대상 날짜 (선택적)
 */
function processCoupangFileAndExecuteRemaining(fileData, fileName, targetDate) {
  console.log('=== Function Start: processCoupangFileAndExecuteRemaining ===');
  console.log('Parameters:', { fileName, targetDate });
  
  try {
    // 1. 쿠팡 파일 처리
    const coupangResult = CoupangProcessor.processCoupangFile(fileData, fileName);
    logUpdate('🛍️ 쿠팡 데이터 처리', coupangResult);
    
    if (!coupangResult.success) {
      console.error('쿠팡 파일 처리 실패:', coupangResult.error);
      return { success: false, error: '쿠팡 파일 처리 실패: ' + coupangResult.error };
    }
    
    // 2. 품목별 분할 (필수) - 지정된 날짜 또는 현재 작업 중인 날짜 사용
    const workingDate = targetDate || getCurrentWorkingDate();
    console.log(`품목별 분할에 사용할 날짜: ${workingDate}`);
    const splitResult = ProductSpliter.splitByProduct(workingDate);
    logUpdate('📊 품목별 분할', splitResult);
    
    if (!splitResult.success) {
      logUpdate('❌ 품목별 분할 실패 - 워크플로우 중단', splitResult);
      return { success: false, error: '품목별 분할 실패: ' + splitResult.error };
    }
    
    // 3. 품목별 시트 생성 및 엑셀 다운로드 (동일한 날짜 사용)
    const downloadResult = ProductDownloader.downloadProductSheets(workingDate);
    logUpdate('📥 품목별 엑셀 생성', downloadResult);
    
    if (!downloadResult.success) {
      logUpdate('⚠️ 통합 워크플로우 중단: 엑셀 생성 실패', downloadResult);
      return { success: false, error: '엑셀 생성 실패: ' + downloadResult.error };
    }
    
    // 4. 자동 이메일 전송 (동일한 날짜 사용)
    const emailResult = sendEmailWithProductSheets(workingDate);
    logUpdate('📧 자동 이메일 전송', emailResult);
    
    if (emailResult.success) {
      logUpdate('🎉 통합 워크플로우 전체 완료!', {
        success: true,
        completedSteps: [
          '검산완료',
          '쿠팡처리',
          '품목별생성',
          '엑셀생성',
          '이메일전송'
        ],
        time: new Date().toLocaleString('ko-KR')
      });
      
      // 작업 완료 후 임시 저장된 날짜 정리
      PropertiesService.getScriptProperties().deleteProperty('CURRENT_WORKING_DATE');
      console.log('임시 저장된 작업 날짜 정리 완료');
      
      console.log('=== Function End: processCoupangFileAndExecuteRemaining SUCCESS ===');
      return { 
        success: true, 
        message: '모든 과정이 완료되었습니다. 출고 요청 이메일이 발송되었습니다.' 
      };
    } else {
      // 실패 시에도 임시 저장된 날짜 정리
      PropertiesService.getScriptProperties().deleteProperty('CURRENT_WORKING_DATE');
      console.log('실패 시 임시 저장된 작업 날짜 정리 완료');
      
      logUpdate('⚠️ 이메일 전송 실패하지만 데이터 처리는 완료', emailResult);
      return { 
        success: false, 
        error: '이메일 전송 실패: ' + emailResult.error 
      };
    }
    
  } catch (error) {
    console.error('ERROR in processCoupangFileAndExecuteRemaining:', error.toString());
    console.error('Error stack:', error.stack);
    
    // 오류 시에도 임시 저장된 날짜 정리
    PropertiesService.getScriptProperties().deleteProperty('CURRENT_WORKING_DATE');
    console.log('오류 시 임시 저장된 작업 날짜 정리 완료');
    
    logUpdate('❌ 통합 워크플로우 오류', { success: false, error: error.toString() });
    console.log('=== Function End: processCoupangFileAndExecuteRemaining FAILED ===');
    return { success: false, error: error.toString() };
  }
}

/**
 * 디버깅용 함수 - 쿠팡 파일의 헤더와 데이터 구조 확인
 */
function debugCoupangFile() {
  console.log('=== 쿠팡 파일 디버깅 시작 ===');
  
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = spreadsheet.getSheets();
  
  // 쿠팡 시트 찾기
  let coupangSheet = null;
  for (const sheet of sheets) {
    const name = sheet.getName();
    if (name.includes('쿠팡') || name.includes('Delivery')) {
      coupangSheet = sheet;
      console.log(`✅ 쿠팡 시트 발견: "${name}"`);
      break;
    }
  }
  
  if (!coupangSheet) {
    console.log('❌ 쿠팡 시트를 찾을 수 없습니다.');
    return;
  }
  
  const data = coupangSheet.getDataRange().getValues();
  const headers = data[0];
  const firstDataRow = data[1];
  
  console.log('\n=== 헤더 정보 ===');
  headers.forEach((header, index) => {
    console.log(`${String.fromCharCode(65 + index)}열 (${index}): "${header}"`);
  });
  
  console.log('\n=== 첫 번째 데이터 행 ===');
  if (firstDataRow) {
    console.log('M열 (12):', firstDataRow[12]);
    console.log('P열 (15):', firstDataRow[15]);
    console.log('W열 (22):', firstDataRow[22]);
    console.log('Y열 (24):', firstDataRow[24]);
    console.log('Z열 (25):', firstDataRow[25]);
    console.log('AA열 (26):', firstDataRow[26]);
    console.log('AB열 (27):', firstDataRow[27]);
  }
  
  console.log('\n=== 총 데이터 행 수 ===');
  console.log(`헤더 포함 총 ${data.length}행`);
  console.log(`데이터 행: ${data.length - 1}행`);
}